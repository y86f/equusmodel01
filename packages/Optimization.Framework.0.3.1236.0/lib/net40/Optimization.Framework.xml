<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Optimization.Framework</name>
  </assembly>
  <members>
    <member name="M:Optimization.ConflictingSet.#ctor(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IVariable},System.Collections.Generic.IEnumerable{Optimization.Interfaces.IVariable},System.Collections.Generic.IEnumerable{Optimization.Constraint},System.Collections.Generic.IEnumerable{Optimization.Constraint},System.Collections.Generic.IEnumerable{System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double}})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.ConflictingSet" /> class.
            </summary>
      <param name="variablesUb">The variables for which the upper bounds are conflicting.</param>
      <param name="variablesLb">The variables for which the lower bounds are conflicting.</param>
      <param name="constraints">The conflicting constraints.</param>
      <param name="sos">The conflicting sos stes.</param>
    </member>
    <member name="P:Optimization.ConflictingSet.VariablesUB">
      <summary>
            Gets the variables for which the upper bounds are conflicting
            </summary>
    </member>
    <member name="P:Optimization.ConflictingSet.VariablesLB">
      <summary>
            Gets the variables for which the lower bounds are conflicting.
            </summary>
    </member>
    <member name="P:Optimization.ConflictingSet.ConstraintsLB">
      <summary>
            Gets the conflicting constraints where the lower bound is in conflict.
            </summary>
    </member>
    <member name="P:Optimization.ConflictingSet.ConstraintsUB">
      <summary>
            Gets the conflicting constraints where the upper bound is in conflict.
            </summary>
    </member>
    <member name="P:Optimization.ConflictingSet.SOS">
      <summary>
            Gets the conflicting SOS sets.
            </summary>
    </member>
    <member name="T:Optimization.Expression">
      <summary>
            An expression essentially is a tree which stores operators on subtrees which can either be Expressions or Terms themselves
            </summary>
    </member>
    <member name="M:Optimization.Expression.Evaluate(System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the expression using the specified variable values.
            </summary>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="M:Optimization.Expression.Sum(System.Collections.Generic.IEnumerable{Optimization.Expression})">
      <summary>
            Sums the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <requires csharp="expressions != null" vb="expressions &lt;&gt; Nothing">expressions != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.Sum(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Sums up the specified values.
            </summary>
      <param name="values">The expressions.</param>
      <returns />
      <requires csharp="values != null" vb="values &lt;&gt; Nothing">values != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.Sum(System.Collections.Generic.IEnumerable{Optimization.Term})">
      <summary>
            Sums the specified terms.
            </summary>
      <param name="expressions">The terms.</param>
            BMK: variablename: expressions? terms?
        </member>
    <member name="M:Optimization.Expression.Sum(System.Collections.Generic.IEnumerable{Optimization.Variable})">
      <summary>
            Sums the specified variables.
            </summary>
      <param name="variables">The variables.</param>
      <returns />
      <requires csharp="variables != null" vb="variables &lt;&gt; Nothing">variables != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.Sum(System.Int32,System.Int32,System.Func{System.Int32,Optimization.Expression})">
      <summary>
            Sums the specified range of expressions.
            </summary>
      <param name="start">The start.</param>
      <param name="count">The count.</param>
      <param name="selector">The selector.</param>
      <returns />
      <requires csharp="selector != null" vb="selector &lt;&gt; Nothing">selector != null</requires>
      <requires csharp="count &gt;= 0" vb="count &gt;= 0">count &gt;= 0</requires>
      <requires csharp="start &gt;= 0" vb="start &gt;= 0">start &gt;= 0</requires>
      <requires csharp="start + count - 1 &lt;= int.MaxValue" vb="start + count - 1 &lt;= int.MaxValue">start + count - 1 &lt;= int.MaxValue</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.Sum(System.Int32,System.Int32,System.Func{System.Int32,Optimization.Term})">
      <summary>
            Sums the specified range of terms.
            </summary>
      <param name="start">The start.</param>
      <param name="count">The count.</param>
      <param name="selector">The selector.</param>
      <returns />
      <requires csharp="selector != null" vb="selector &lt;&gt; Nothing">selector != null</requires>
      <requires csharp="count &gt;= 0" vb="count &gt;= 0">count &gt;= 0</requires>
      <requires csharp="start &gt;= 0" vb="start &gt;= 0">start &gt;= 0</requires>
      <requires csharp="start + count - 1 &lt;= int.MaxValue" vb="start + count - 1 &lt;= int.MaxValue">start + count - 1 &lt;= int.MaxValue</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Multiply(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="expression">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="expression != null" vb="expression &lt;&gt; Nothing">expression != null</requires>
      <requires csharp="expression2 != null" vb="expression2 &lt;&gt; Nothing">expression2 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Multiply(System.Double,Optimization.Expression)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
    </member>
    <member name="M:Optimization.Expression.op_Multiply(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Multiply(Optimization.Expression,Optimization.Variable)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="expression">The expression.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Division(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator /.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>
            The result of the operator.
            </returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="constant != 0.0" vb="constant &lt;&gt; 0">constant != 0.0</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_LessThanOrEqual(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_GreaterThanOrEqual(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_LessThanOrEqual(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression1, null)" vb="Not Equals(expression1, Nothing)">!object.Equals(expression1, null)</requires>
      <requires csharp="!Equals(expression2, null)" vb="Not Equals(expression2, Nothing)">!object.Equals(expression2, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Equality(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression1, null)" vb="Not Equals(expression1, Nothing)">!object.Equals(expression1, null)</requires>
      <requires csharp="!Equals(expression2, null)" vb="Not Equals(expression2, Nothing)">!object.Equals(expression2, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Equality(Optimization.Variable,Optimization.Expression)">
      <summary>
            Creates a new equality constraint
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The a new constraint as the result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="!Equals(variable, null)" vb="Not Equals(variable, Nothing)">!object.Equals(variable, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Equality(Optimization.Expression,Optimization.Variable)">
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="!Equals(variable, null)" vb="Not Equals(variable, Nothing)">!object.Equals(variable, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Inequality(Optimization.Expression,Optimization.Variable)">
      <summary>
            Please construct inequalities using &lt;= and &gt;=
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Expression.op_Inequality(Optimization.Variable,Optimization.Expression)">
      <summary>
            Please construct inequalities using &lt;= and &gt;=
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Expression.op_Equality(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="expression">The expression.</param>
      <param name="value">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Equality(System.Double,Optimization.Expression)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="value">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>
            The result of the operator.
            </returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Inequality(System.Double,Optimization.Expression)">
      <summary>
            Please construct inequalities using &lt;= and &gt;=
            </summary>
      <param name="expression">The expression.</param>
      <param name="value">The value.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Expression.op_Inequality(Optimization.Expression,System.Double)">
      <summary>
            Please construct inequalities using &lt;= and &gt;=
            </summary>
      <param name="expression">The expression.</param>
      <param name="value">The value.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Expression.op_Inequality(Optimization.Expression,Optimization.Expression)">
      <summary>
            Please construct inequalities using &lt;= and &gt;=
            </summary>
      <param name="expression">The expression.</param>
      <param name="expression2">The expression2.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Expression.op_GreaterThanOrEqual(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression1, null)" vb="Not Equals(expression1, Nothing)">!object.Equals(expression1, null)</requires>
      <requires csharp="!Equals(expression2, null)" vb="Not Equals(expression2, Nothing)">!object.Equals(expression2, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_GreaterThanOrEqual(Optimization.Expression,Optimization.Variable)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="expression">The expression.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="!Equals(variable, null)" vb="Not Equals(variable, Nothing)">!object.Equals(variable, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_LessThanOrEqual(Optimization.Expression,Optimization.Variable)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="expression">The expression.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="!Equals(variable, null)" vb="Not Equals(variable, Nothing)">!object.Equals(variable, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_LessThanOrEqual(Optimization.Variable,Optimization.Expression)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="!Equals(variable, null)" vb="Not Equals(variable, Nothing)">!object.Equals(variable, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_LessThanOrEqual(System.Double,Optimization.Expression)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_GreaterThanOrEqual(System.Double,Optimization.Expression)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_GreaterThanOrEqual(Optimization.Variable,Optimization.Expression)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="!Equals(variable, null)" vb="Not Equals(variable, Nothing)">!object.Equals(variable, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Addition(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression1, null)" vb="Not Equals(expression1, Nothing)">!object.Equals(expression1, null)</requires>
      <requires csharp="!Equals(expression2, null)" vb="Not Equals(expression2, Nothing)">!object.Equals(expression2, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Addition(Optimization.Expression,Optimization.Variable)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="expression1">The expression.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="expression1 != null" vb="expression1 &lt;&gt; Nothing">expression1 != null</requires>
      <requires csharp="variable != null" vb="variable &lt;&gt; Nothing">variable != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Addition(Optimization.Variable,Optimization.Expression)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression1">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="variable != (Optimization.Variable)null" vb="variable &lt;&gt; ((Optimization.Variable)Nothing) ">variable != (Optimization.Variable)null</requires>
      <requires csharp="expression1 != null" vb="expression1 &lt;&gt; Nothing">expression1 != null</requires>
    </member>
    <member name="M:Optimization.Expression.op_Addition(Optimization.Expression,System.Double)">
      <summary>
             Adds a constant to an expression
            </summary>
      <param name="expression" />
      <param name="constant" />
      <returns />
      <requires csharp="expression != null" vb="expression &lt;&gt; Nothing">expression != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Addition(System.Double,Optimization.Expression)">
      <summary>
             Adds a constant to an expression
            </summary>
      <param name="constant" />
      <param name="expression" />
      <returns />
      <requires csharp="expression != null" vb="expression &lt;&gt; Nothing">expression != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Subtraction(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!expression1.Equals(null)" vb="Not expression1.Equals(Nothing)">!expression1.Equals(null)</requires>
      <requires csharp="!expression2.Equals(null)" vb="Not expression2.Equals(Nothing)">!expression2.Equals(null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Subtraction(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="expression1">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="expression1 != null" vb="expression1 &lt;&gt; Nothing">expression1 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Subtraction(System.Double,Optimization.Expression)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression1">The expression1.</param>
      <returns>
            The result of the operator.
            </returns>
      <requires csharp="expression1 != null" vb="expression1 &lt;&gt; Nothing">expression1 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Subtraction(Optimization.Variable,Optimization.Expression)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="!Equals(variable, null)" vb="Not Equals(variable, Nothing)">!object.Equals(variable, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Subtraction(Optimization.Expression,Optimization.Variable)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="expression">The expression.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="!Equals(variable, null)" vb="Not Equals(variable, Nothing)">!object.Equals(variable, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Expression.Normalize">
      <summary>
            Flattens the expression. Only works for linear expressions and the result is a sum of terms + a constant.
            </summary>
      <returns />
    </member>
    <member name="P:Optimization.Expression.isLinear">
      <summary>
            Gets or sets a value indicating whether this instance is linear.
            </summary>
      <value>
        <c>true</c> if this instance is linear; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Expression.Variables">
      <summary>
            Gets the variables in this expression.
            </summary>
      <value>The variables.</value>
    </member>
    <member name="P:Optimization.Expression.Terms">
      <summary>
            Gets a list of the terms in this expression. It does not contain any operators and does not tell you anything aobut how they are combined with operators.
            </summary>
      <value>The terms.</value>
    </member>
    <member name="P:Optimization.Expression.Constant">
      <summary>
            Gets the constant of this expression.
            </summary>
      <value>The constant.</value>
    </member>
    <member name="P:Optimization.Expression.ExpressionLowerEstimate">
      <summary>
            Gives a lower estimate on the value of an Expression.
            ToDO: Very experimental. Should be able to estimate linear combinations of variables with finite bounds.
            In the default case -infinity is returned!
            </summary>
    </member>
    <member name="P:Optimization.Expression.ExpressionUpperEstimate">
      <summary>
            Gives an upper estimate in the value of an Expression.
            ToDO: Very experimental. Should be able to estimate linear combinations of variables with finite bounds.
            In the default case -infinity is returned!
            </summary>
    </member>
    <member name="P:Optimization.Expression.BigM">
      <getter>
        <requires description="The variables used in your constraints have to have finite bounds." csharp="All&lt;Optimization.Term&gt;(this.Terms, delegate (Optimization.Term term) {&#xD;&#xA;    if (!(term.Factor &gt; 0.0))&#xD;&#xA;    {&#xD;&#xA;        return term.Variable.LowerBound &gt; double.NegativeInfinity;&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;    return term.Variable.UpperBound &lt; double.PositiveInfinity;&#xD;&#xA;&#xD;&#xA;})" vb="All(Me.Terms, delegate (term As Optimization.Term) {&#xD;&#xA;    If !(term.Factor &gt; 0 Then&#xD;&#xA;    Return term.Variable.LowerBound &gt; -unendlich&#xD;&#xA;    Return term.Variable.UpperBound &lt; +unendlich&#xD;&#xA;})">System.Linq.Enumerable.All&lt;Optimization.Term&gt;(this.Terms, delegate (Optimization.Term term) {
    if (!(term.Factor &gt; 0.0))
    {
        return term.Variable.LowerBound &gt; double.NegativeInfinity;

    }
    return term.Variable.UpperBound &lt; double.PositiveInfinity;

})</requires>
      </getter>
    </member>
    <member name="T:Optimization.ConstantExpression">
      <summary>
            A ConstantExpression only holds a double value but can be used as part of an expression
            </summary>
    </member>
    <member name="M:Optimization.ConstantExpression.#ctor(System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.ConstantExpression" /> class.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Implicit(System.Double)~Optimization.ConstantExpression">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Double" /> to <see cref="T:Optimization.ConstantExpression" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Multiply(System.Double,Optimization.ConstantExpression)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="factor">The factor.</param>
      <param name="expression">The constant expression.</param>
      <returns>A new <see cref="T:Optimization.ConstantExpression" />.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Multiply(Optimization.ConstantExpression,System.Double)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="expression">The expression.</param>
      <param name="factor">The factor.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Addition(System.Double,Optimization.ConstantExpression)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Addition(Optimization.ConstantExpression,System.Double)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Subtraction(Optimization.ConstantExpression,System.Double)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Subtraction(System.Double,Optimization.ConstantExpression)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Implicit(System.Int32)~Optimization.ConstantExpression">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Int32" /> to <see cref="T:Optimization.ConstantExpression" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Optimization.ConstantExpression.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Optimization.ConstantExpression.Constant">
      <summary>
            Gets the constant.
            </summary>
    </member>
    <member name="P:Optimization.ConstantExpression.isLinear">
      <summary>
            Gets or sets a value indicating whether this instance is linear.
            </summary>
      <value>
              Always <c>true</c> because a <see cref="T:Optimization.ConstantExpression" /> is always linear.
            </value>
    </member>
    <member name="P:Optimization.ConstantExpression.Variables">
      <summary>
            Gets the variables. 
            </summary>
      <value>
              Always <c>null</c> because a <see cref="T:Optimization.ConstantExpression" /> has no Variables.
            </value>
    </member>
    <member name="P:Optimization.ConstantExpression.Terms">
      <summary>
            Gets the terms.
            </summary>
      <value>
              Always <c>null</c> because a <see cref="T:Optimization.ConstantExpression" /> has no Terms.
            </value>
    </member>
    <member name="M:Optimization.Interfaces.ICanAsAConstraintRegisterAModel.Unregister(Optimization.Interfaces.ICanTrackPropertyChangesInConstraints)">
      <summary>
            Unregisters the specified model.
            </summary>
      <param name="model">The solver.</param>
    </member>
    <member name="M:Optimization.Interfaces.ICanAsAConstraintRegisterAModel.Register(Optimization.Interfaces.ICanTrackPropertyChangesInConstraints)">
      <summary>
            Registers the specified solver to work on this problem
            </summary>
      <param name="model">The solver.</param>
    </member>
    <member name="T:Optimization.Constraint">
      <summary>
            Represents an constraint
            </summary>
      <author>lbeckmann</author>
    </member>
    <member name="M:Optimization.Constraint.#ctor(Optimization.Expression,System.String,System.Double,System.Double,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Constraint" /> class.
            </summary>
      <param name="expression">The expression.</param>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="stochasticStage">The stochastic stage of this constraint</param>
    </member>
    <member name="M:Optimization.Constraint.LessThanOrEqual(Optimization.Expression,Optimization.Expression)">
      <summary>
            Compares two expressions whether the first expression is lower or equal the second expression.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with upper bound of zero</returns>
      <requires csharp="expression1 != null" vb="expression1 &lt;&gt; Nothing">expression1 != null</requires>
      <requires csharp="expression2 != null" vb="expression2 &lt;&gt; Nothing">expression2 != null</requires>
    </member>
    <member name="M:Optimization.Constraint.Equals(Optimization.Expression,Optimization.Expression)">
      <summary>
            Compares the specified expressions.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with lower and upper bound of zero</returns>
      <requires csharp="expression1 != null" vb="expression1 &lt;&gt; Nothing">expression1 != null</requires>
      <requires csharp="expression2 != null" vb="expression2 &lt;&gt; Nothing">expression2 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures description="The lower bound of the constraint is 0" csharp="result.LowerBound == 0.0" vb="result.LowerBound = 0">result.LowerBound == 0.0</ensures>
      <ensures description="The upper bound of the constraint is 0" csharp="result.UpperBound == 0.0" vb="result.UpperBound = 0">result.UpperBound == 0.0</ensures>
    </member>
    <member name="M:Optimization.Constraint.GreaterThanOrEqual(Optimization.Expression,Optimization.Expression)">
      <summary>
            Compares two expressions whether the first expression is greater or equal the second expression.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with lower bound of zero</returns>
      <requires csharp="expression1 != null" vb="expression1 &lt;&gt; Nothing">expression1 != null</requires>
      <requires csharp="expression2 != null" vb="expression2 &lt;&gt; Nothing">expression2 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Constraint.LessThanOrEqual(Optimization.Expression,System.Double)">
      <summary>
            Compares the expression to a constant whether its less or equal.
            </summary>
      <param name="expression1">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with upper bound of zero</returns>
      <requires csharp="expression1 != null" vb="expression1 &lt;&gt; Nothing">expression1 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Constraint.Equals(Optimization.Expression,System.Double)">
      <summary>
            Compares the expression to a constant.
            </summary>
      <param name="expression1">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with lower and upper bound of zero</returns>
      <requires csharp="expression1 != null" vb="expression1 &lt;&gt; Nothing">expression1 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Constraint.GreaterThanOrEqual(Optimization.Expression,System.Double)">
      <summary>
            Compares the expression to a constant whether its greater or equal.
            </summary>
      <param name="expression1">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with lower bound of zero</returns>
      <requires csharp="expression1 != null" vb="expression1 &lt;&gt; Nothing">expression1 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Constraint.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Constraint.op_BitwiseOr(Optimization.Constraint,Optimization.Constraint)">
      <summary>
            Use this operator if you either want constraint1 or constraint2 or both to evaluate to true in a feasible solution.
            </summary>
      <param name="constraint1">The constraint1.</param>
      <param name="constraint2">The constraint2.</param>
      <returns>
            The result of the operator.
            </returns>
    </member>
    <member name="M:Optimization.Constraint.op_BitwiseOr(System.Collections.Generic.List{Optimization.Constraint},Optimization.Constraint)">
      <summary>
            Use this operator if you either want the constraintGroup or constraint2 or both to evaluate to true in a feasible solution.
            </summary>
      <param name="constraintGroup">The constraints.</param>
      <param name="constraint2">The constraint2.</param>
      <returns>
            The result of the operator.
            </returns>
    </member>
    <member name="M:Optimization.Constraint.op_LogicalNot(Optimization.Constraint)">
      <summary>
            Negates a constraint. If you have l&lt;x&lt;u, then this will be transformed into
            x&gt;u+epsilon and x&lt;l-epsilon
            </summary>
      <param name="constraint">The constraint.</param>
      <returns>
            A Not representing the negated constraint.
            </returns>
    </member>
    <member name="M:Optimization.Constraint.Where(Optimization.Constraint)">
      <summary>
            This constraint should only hold if the provided condition also holds, in other words: if(condition) then 'this' must hold
            </summary>
      <param name="condition">The condition.</param>
      <returns />
    </member>
    <member name="P:Optimization.Constraint.StochasticStage">
      <summary>
             StochasticStage this  of this constraint
            </summary>
    </member>
    <member name="P:Optimization.Constraint.Name">
      <summary>
            Unique name of this constraint.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Constraint.LowerBound">
      <summary>
            Lower bound (left hand side) of this constraint.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Constraint.UpperBound">
      <summary>
            Upper bound (right hand side) of this constraint.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Constraint.Expression">
      <summary>
            Expression of this constraint.
            </summary>
      <value />
    </member>
    <member name="T:Optimization.ConstraintType">
      <summary>
            Specifies a type of constraint
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.IExpressionVisitor`1.Visit(Optimization.Expression)">
      <requires csharp="exp != null" vb="exp &lt;&gt; Nothing">exp != null</requires>
    </member>
    <member name="T:Optimization.Exporter.ExpressionNormalizer">
      <summary>
             Class used for normalizing an expression.
             ConstantExpressions should be added up or expanded (to show if the expression is linear or quadratic or nonlinear)
             Another goal is to eliminate as many ConstantExpressions as possible.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.Visit(Optimization.Expression)">
      <summary>
            Returns the normalized expression
            </summary>
      <param name="expression">The Optimization.Model.Expression</param>
      <returns>The normalized expression</returns>
      <requires inheritedFrom="M:Optimization.Interfaces.IExpressionVisitor`1.Visit(Optimization.Expression)" inheritedFromTypeName="IExpressionVisitor" csharp="exp != null" vb="exp &lt;&gt; Nothing">exp != null</requires>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.VisitIPlus(Optimization.Operators.Interfaces.IPlus,System.Double)">
      <summary>
            Normalizes an expression of the type IPlus, multiplied by an external factor.
            </summary>
      <param name="iPlus">The expression of type IPlus</param>
      <param name="extFactor">The external multiplier</param>
      <returns>The normalized expression</returns>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.VisitITimes(Optimization.Operators.Interfaces.ITimes,System.Double)">
      <summary>
            Normalizes an expression of the type ITimes, multiplied by an external factor.
            </summary>
      <param name="iTimes">The expression of type ITimes</param>
      <param name="extFactor">The external multiplier</param>
      <returns>The normalized expression</returns>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.VisitTerm(Optimization.Term,System.Double)">
      <summary>
            Returns an Term expression, multiplied by the factor (in case the factor is not 0)
            </summary>
      <param name="Term">The orignal Term</param>
      <param name="factor">The multiplier, default is 0(in this case the original Term is returned)</param>
      <returns>The possibly altered Term</returns>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.VisitConstantExpression(Optimization.ConstantExpression)">
      <summary>
            Returns the ConstantExpression
            </summary>
      <param name="ConstantExpression">The ConstantExpression</param>
      <returns>The ConstantExpression</returns>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.GetTermsToAdd(Optimization.Operators.Interfaces.IPlus,System.Collections.Generic.HashSet{Optimization.Term}@,System.Collections.Generic.HashSet{Optimization.Operators.Interfaces.ITimes}@,System.Collections.Generic.HashSet{Optimization.Operators.Interfaces.IPlus}@,System.Double@,System.Double)">
      <summary>
            Returns all expressions of type Term, ITimes, IPlus and a factor of type double of an IPlus expression.
            </summary>
      <param name="plusIn">The expression of type IPlus for which all elements should be identified</param>
      <param name="termsOut">A list of expressions of type Term contained in the IPlus expression</param>
      <param name="timesOut">A list of expressions of type ITimes contained in the IPlus expression</param>
      <param name="plusOut">A list of expressions of type IPlus contained in the IPlus expression</param>
      <param name="factor">The factor contained in the IPlus expression</param>
      <param name="extFactor">The factor which is multiplied with the whole IPlus expression, if non is specified the default value is 1, so that the expression is not falsified</param>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.GetTermsToMult(Optimization.Operators.Interfaces.ITimes,System.Collections.Generic.HashSet{Optimization.Term}@,System.Collections.Generic.HashSet{Optimization.Operators.Interfaces.ITimes}@,System.Collections.Generic.HashSet{Optimization.Operators.Interfaces.IPlus}@,System.Double@,System.Double)">
      <summary>
            Returns all expressions of type Term, ITimes, IPlus and a factor of type double of an ITimes expression.
            </summary>
      <param name="timesIn">The expression of type ITimes for which all elements should be identified</param>
      <param name="termsOut">A list of expressions of type Term contained in the ITimes expression</param>
      <param name="timesOut">A list of expressions of type ITimes contained in the ITimes expression</param>
      <param name="plusOut">A list of expressions of type IPlus contained in the ITimes expression</param>
      <param name="factor">The factor contained in the ITimes expression</param>
      <param name="extFactor">The factor which is multiplied with the whole ITimes expression, if non is specified the default value is 1, so that the expression is not falsified</param>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.expandPlus(System.Collections.Generic.HashSet{Optimization.Operators.Interfaces.IPlus},System.Collections.Generic.HashSet{Optimization.Term})">
      <summary>
            Expands expressions of type Term and IPlus and returns an IPlus expression
            </summary>
      <param name="plus">The list of expression of type IPlus</param>
      <param name="terms">The list of expression of type Term</param>
      <returns>The expanded expression of type IPlus</returns>
    </member>
    <member name="T:Optimization.Exporter.LPExporter">
      <summary>
            This class can export a model into a stream, using the LP file format.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.#ctor(System.IO.Stream)">
      <summary>
            Creates a new instance of class <see cref="T:Optimization.Exporter.LPExporter" />.
            </summary>
      <param name="filestream">The stream in which the model should be written.</param>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Write(Optimization.Model)">
      <summary>
            Delegates to a method for each part of a LP file.
            </summary>
      <param name="model">The model that should be exported.</param>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.ChangeVariableAndRowNames">
      <summary>
            Variablenames and rownames are changed, trimming spaces and special characters
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.ModelName">
      <summary>
            Writes the model name as a comment into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Objective">
      <summary>
            Writes the objective into the stream, including name and the corresponding expression.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Constraints">
      <summary>
            Writes all constraints into the stream, including name, the corresponding expression and the right-hand side.
            Also included are constraints modelling sos3 sets.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Variables">
      <summary>
            Writes all variables into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.General">
      <summary>
            Writes all general variables into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Binary">
      <summary>
            Writes all binary variables into the strem.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.SOS">
      <summary>
            Writes all variables included in a SOS1 or SOS2 set into the stream.
            SOS 3 is modeled in the "Constraints section".
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.End">
      <summary>
            Writes "End" into the stream. Symbolizes the end of the file.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.WriteSOS(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double},Optimization.SOSType,System.Int32)">
      <summary>
            Method to write all variables of a SOS set into the stream.
            </summary>
      <param name="sosset">The SOS set</param>
      <param name="sosType">The type of the SOS set</param>
      <param name="counter">The i-th element being written into the stream</param>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.OutputLine(System.String)">
      <summary>
            Writes a string into the stream, taking care of the maximal number of characters in a line.
            </summary>
      <param name="line">The string, which should be outputed.</param>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Output(System.String)">
      <summary>
            Writes a string into the stream, not looking at the maximal number of characters.
            </summary>
      <param name="output">The string, which should be outputed.</param>
    </member>
    <member name="T:Optimization.Exporter.MPSExporter">
      <summary>
            This class can export a model into a stream, using the MPS file format.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.#ctor(System.IO.Stream)">
      <summary>
            Creates a new instance of class <see cref="T:Optimization.Exporter.MPSExporter" />.
            </summary>
      <param name="filestream">The stream in which the model should be written.</param>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.Write(Optimization.Model)">
      <summary>
            Delegates to a method for each section of a MPS file.
            </summary>
      <param name="model">The model that should be exported.</param>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.NAME">
      <summary>
            Writes the model name into the NAME section into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.ROWS">
      <summary>
            Writes all names of all constraints and the objective (row) into the stream, including a type indicating the rhs-type of the constraint or objective.
            For each row the non-zero elements and the corresponding coefficients, the rhs value and the range are saved.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.AnalyseConstraint(Optimization.Constraint,System.Double)">
      <summary>
            Analyse how the constraint is build up. E.g. if all terms are multiplied by -1.
            </summary>
      <param name="constraint">The constraint to analyse</param>
      <param name="bound">The conputed bound</param>
      <returns>True if the coefficients in all terms must be multiplied by -1, else false</returns>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.FindConstantExpressionInITimes(Optimization.Operators.Interfaces.ITimes,Optimization.Constraint,System.Double)">
      <summary>
            Seaches for a constant in an ITimes expression and returns true if the constant is -1.
            </summary>
      <param name="expression">The ITimes expression</param>
      <param name="constraint">The constraint in which the expression is included</param>
      <param name="bound">The computed bound</param>
      <returns>True if the coefficients in all terms must be multiplied by -1, else false</returns>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.COLUMNS">
      <summary>
            Writes for each non-zero element the corresponding rows(constraint or objective) into the stream.
            For integer variables or sos sets a MARKER is used to indicate the meaning, the start and the end.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.SOSMarker(System.Collections.Generic.IEnumerable{System.Collections.Generic.Dictionary{Optimization.Variable,System.Double}},Optimization.SOSType)">
      <summary>
            Writes a MARKER block for a sos set into the stream.
            </summary>
      <param name="sosSets">The sos set, which should be _stringBuilder.Appended.</param>
      <param name="sosType">The sos-type of the sos set.</param>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.RHS">
      <summary>
            Writes for all constraints the name and the rhs-value into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.RANGES">
      <summary>
            Writes the range for each constraint, having an upper and a lower bound, into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.BOUNDS">
      <summary>
            Writes for all variales the upper bound or the lower bound or the bound type and the corresponding value into te stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.SOS">
      <summary>
            Writes all members for each SOS2 set into the SOS section into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.ENDATA">
      <summary>
            Writes the ENDATA section into the stream, indicating the end of the file.
            </summary>
    </member>
    <member name="T:Optimization.Exporter.LPStringExprVisitor">
      <summary>
            A class taking an Expression and returning the corresponding representation in LP file format.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Creates a new instance of the <see cref="T:Optimization.Exporter.LPStringExprVisitor" /> class.
            </summary>
      <param name="changedVariableNames">The reference to a Dictionary saving all variables which are truncaded and their original name</param>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.VisitTerm(Optimization.Term,System.Boolean)">
      <summary>
            Returns a string representing an Term in LP file format.
            </summary>
      <param name="term">The Term</param>
      <param name="negate">True if the term must be negated</param>
      <returns>The string representing the Term</returns>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.VisitConstant(Optimization.ConstantExpression,System.Boolean)">
      <summary>
            Returns a string representing an ConstantExpression in LP file format.
            </summary>
      <param name="constantExpression">The ConstantExpression</param>
      <param name="negate">True if the constant must be negated</param>
      <returns>The string representing the ConstantExpression</returns>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.VisitTimes(Optimization.Operators.Interfaces.ITimes,System.Boolean)">
      <summary>
            Returns a string representing an expression of type ITimes in LP file format.
            </summary>
      <param name="times">The expression of type ITimes</param>
      <param name="negate">True if all elements must be negated</param>
      <returns>The string representing the expression of type ITimes</returns>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.VisitPlus(Optimization.Operators.Interfaces.IPlus,System.Boolean)">
      <summary>
            Returns a string representing an expression of type IPlus in LP file format.
            </summary>
      <param name="plus">The expression of type IPlus</param>
      <param name="negate">True if all elements must be negated</param>
      <returns>The string representing the expression of type IPlus</returns>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.TimesScalar(System.Double,Optimization.Expression)">
      <summary>
            Returns a string representing a scalar product in LP file format.
            </summary>
      <param name="factor">The factor</param>
      <param name="expr">The Expression</param>
      <returns>The string representing the scalar product</returns>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.TimesQuadratic(System.Double,System.String[])">
      <summary>
            Returns a string representing a quadratic expression in LP file format.
            </summary>
      <param name="factor">The factor</param>
      <param name="vars">The names of the variables</param>
      <returns>The string representing the quadratic expression</returns>
    </member>
    <member name="T:Optimization.ExpressionNormalizer">
      <summary>
            This is a helper class to normalize
            </summary>
    </member>
    <member name="T:Optimization.Importer.MPS.MpsParsingException">
      <summary>
            An MPSParsingException is thrown when there is an error while parsing an MPS file
            </summary>
    </member>
    <member name="M:Optimization.Importer.MPS.MpsParsingException.#ctor(System.String)">
      <summary>
            Creates a new MpsParsingException
            </summary>
      <param name="message">The message for the user</param>
    </member>
    <member name="T:Optimization.Operators.Interfaces.INot">
      <summary>
            Describes the interface for the not operator for constraints
            </summary>
    </member>
    <member name="T:Optimization.Operators.Interfaces.IOr">
      <summary>
            Describes the interface for the or operator for constraints
            </summary>
    </member>
    <member name="T:Optimization.Operators.Interfaces.IWhere">
      <summary>
            Describes the interface for the where operator for constraints
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.ICanAsAVariableRegisterAModel.Unregister(Optimization.Interfaces.ICanTrackPropertyChangesInVariables)">
      <summary>
            Unregisters the specified model.
            </summary>
      <param name="model">The solver.</param>
    </member>
    <member name="M:Optimization.Interfaces.ICanAsAVariableRegisterAModel.Register(Optimization.Interfaces.ICanTrackPropertyChangesInVariables)">
      <summary>
            Registers the specified solver to work on this problem
            </summary>
      <param name="model">The solver.</param>
    </member>
    <member name="M:Optimization.Interfaces.ICanTrackPropertyChangesInConstraints.ChangeConstraintLowerBound(System.String,System.Double)">
      <summary>
            Changes the constraint lower bound.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerbound">The lowerbound.</param>
      <returns />
    </member>
    <member name="M:Optimization.Interfaces.ICanTrackPropertyChangesInConstraints.ChangeConstraintUpperBound(System.String,System.Double)">
      <summary>
            Changes the constraint upper bound.
            </summary>
      <param name="name">The name.</param>
      <param name="upperbound">The upperbound.</param>
      <returns />
    </member>
    <member name="M:Optimization.Operators.OperatorConstraint.#ctor(System.Collections.Generic.IEnumerable{Optimization.Constraint},System.Collections.Generic.IEnumerable{Optimization.Constraint})">
      <summary>
            Initializes a new instance of the OperatorConstraint class
            </summary>
      <param name="leftConstraints">Left Constraints</param>
      <param name="rightConstraints">Right Constraints</param>
    </member>
    <member name="T:Optimization.Operators.Not">
      <summary>
            Represents the operator for the not operation for constraints
            </summary>
    </member>
    <member name="M:Optimization.Operators.Not.#ctor(Optimization.Constraint)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Not" /> class.
            </summary>
      <param name="constraint">The constraint.</param>
    </member>
    <member name="T:Optimization.Operators.Or">
      <summary>
            Represents the operator for the or operation for constraints
            </summary>
    </member>
    <member name="T:Optimization.Operators.Where">
      <summary>
            Represents the operator for the where operation for constraints
            </summary>
    </member>
    <member name="T:Optimization.Solver.Interfaces.ISolverEvent">
      <summary>
            An implementing class represents an event that can be fired by a solver
            </summary>
    </member>
    <member name="T:Optimization.Solver.Events.NewBestBoundFoundArgs">
      <summary>
            This event is fired whenever a new incumbent was found during the solution process
            </summary>
    </member>
    <member name="T:Optimization.Solver.Interfaces.ICanSetLicense">
      <summary>
            A solver implementing this interface will be able to set a license
            </summary>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanSetLicense.SetLicenseString(System.String)">
      <summary>
            Will set the license via a license string
            </summary>
      <param name="licenseContents">The contents of a license</param>
    </member>
    <member name="T:Optimization.Solver.Interfaces.ICanProvideStatusInfo">
      <summary>
            If a solver implements this interface it can report certain values during a solve run to the user
            </summary>
    </member>
    <member name="P:Optimization.Solver.Interfaces.ICanProvideStatusInfo.BestBound">
      <summary>
            The current best bound
            </summary>
    </member>
    <member name="P:Optimization.Solver.Interfaces.ICanProvideStatusInfo.RelativeGap">
      <summary>
            The current relative gap
            </summary>
    </member>
    <member name="T:Optimization.Solver.Interfaces.ICanSolve`2">
      <summary>
            Indicates that this solver can solve models of type M and return solutions of type S
            </summary>
      <typeparam name="M">The model type</typeparam>
      <typeparam name="S">The solution type</typeparam>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanSolve`2.Solve(`0,System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Solves the given <paramref name="model" />.
            Optimizes if <paramref name="model" /> contains at least one objective.
            </summary>
      <param name="model">The model to solve.</param>
      <param name="variableValues">Initial values for all or a subset of variables in <paramref name="model" />.</param>
      <returns />
      <exception cref="T:System.NotSupportedException">If this solver instance not supports solving.</exception>
      <exception cref="T:System.InvalidOperationException">If this solver instance is busy.</exception>
      <exception cref="T:System.ArgumentException">If this solver instance cannot handle the kind of <paramref name="model" />.</exception>
    </member>
    <member name="T:Optimization.Solver.Interfaces.IAbortable">
      <summary>
            If a solver can be aborted it should implement this interface
            </summary>
    </member>
    <member name="M:Optimization.Solver.Interfaces.IAbortable.Abort">
      <summary>
            If this solver instance is busy abort the run as soon as possible, or do nothing if this solver instance is not busy.
            </summary>
      <exception cref="T:System.NotSupportedException">If this solver instance not supports aborting.</exception>
    </member>
    <member name="T:Optimization.Interfaces.ISolver">
      <summary>
            Represents a solver instance for mathematical programming problems.
            </summary>
      <author>skramkowski</author>
    </member>
    <member name="M:Optimization.Interfaces.ISolver.ClearLastModel">
      <summary>
            Deletes the internal datastructures of this solver instance.
            </summary>
      <exception cref="T:System.InvalidOperationException">If this solver instance is busy.</exception>
    </member>
    <member name="P:Optimization.Interfaces.ISolver.Configuration">
      <summary>
            The configuration of this solver instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ISolver.IsBusy">
      <summary>
            Is this solver instance busy?
            </summary>
    </member>
    <member name="T:Optimization.Solver.Interfaces.ICanSetCutOff">
      <summary>
            A solver implementing this interface is able to set a cut off value
            </summary>
    </member>
    <member name="P:Optimization.Solver.Interfaces.ICanSetCutOff.SetCutOff">
      <summary>
            Gets or sets the set cut off.
            </summary>
      <value>
            The set cut off.
            </value>
    </member>
    <member name="T:Optimization.FileType">
      <summary>
            The filetype of a model file
            </summary>
    </member>
    <member name="F:Optimization.FileType.MPS">
      <summary>
            MPS
            </summary>
    </member>
    <member name="F:Optimization.FileType.OSiL">
      <summary>
            OSiL
            </summary>
    </member>
    <member name="F:Optimization.FileType.LP">
      <summary>
            LP
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.ICanTrackPropertyChangesInVariables.ChangeVariableLowerBound(System.String,System.Double)">
      <summary>
            Changes the variable lower bound.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerbound">The lowerbound.</param>
      <returns />
    </member>
    <member name="M:Optimization.Interfaces.ICanTrackPropertyChangesInVariables.ChangeVariableUpperBound(System.String,System.Double)">
      <summary>
            Changes the variable upper bound.
            </summary>
      <param name="name">The name.</param>
      <param name="upperbound">The upperbound.</param>
      <returns />
    </member>
    <member name="M:Optimization.Interfaces.ICanTrackPropertyChangesInVariables.ChangeVariableType(System.String,Optimization.VariableType)">
      <summary>
            Changes the type of the variable.
            </summary>
      <param name="name">The name.</param>
      <param name="type">The type.</param>
      <returns />
    </member>
    <member name="T:Optimization.Interfaces.ICanTransform`2">
      <summary>
             A class which implements this interface can convert objects of type M1 to objects of type M2
            </summary>
      <typeparam name="M1">Type to convert from</typeparam>
      <typeparam name="M2">Type to convert to</typeparam>
    </member>
    <member name="T:Optimization.Interfaces.ISetAccessor`2">
      <summary>
            Defines a Set and an Accessor function
            </summary>
      <typeparam name="T">The type of the Set</typeparam>
      <typeparam name="S">The return type of the Accessor function</typeparam>
    </member>
    <member name="P:Optimization.Interfaces.ISetAccessor`2.Set">
      <summary>
            Gets the set.
            </summary>
      <value>The set.</value>
    </member>
    <member name="P:Optimization.Interfaces.ISetAccessor`2.Accessor">
      <summary>
            Gets the accessor.
            </summary>
      <value>The accessor.</value>
    </member>
    <member name="T:Optimization.Interfaces.IVariable">
      <summary>
            Represents a variable in an <see cref="T:Optimization.Interfaces.IModel" />.
            </summary>
      <author>fseidel, skramkowski</author>
    </member>
    <member name="P:Optimization.Interfaces.IVariable.Name">
      <summary>
            Unique name of this variable.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IVariable.LowerBound">
      <summary>
            Lower bound of this variable.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IVariable.UpperBound">
      <summary>
            Upper bound of this variable.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IVariable.Value">
      <summary>
            Gets or sets the value for this variable. This field can be used to assign solution values from a solver to the variables in the original model.
            </summary>
      <value>The value.</value>
    </member>
    <member name="P:Optimization.Interfaces.IVariable.Type">
      <summary>
            Type of this variable.
            </summary>
    </member>
    <member name="T:Optimization.ModelBehavior">
      <summary>
            Describes the behavior of a model when adding constraints
            </summary>
    </member>
    <member name="F:Optimization.ModelBehavior.Manual">
      <summary>
            Variables in a constraint will not be added to the model, you need to do this manually beforehand
            </summary>
    </member>
    <member name="F:Optimization.ModelBehavior.Auto">
      <summary>
            Variables in a constraint will be added to the model automatically
            </summary>
    </member>
    <member name="T:Optimization.ObjectiveSense">
      <summary>
            Sense of an <see cref="!:IObjective" />.
            </summary>
    </member>
    <member name="F:Optimization.ObjectiveSense.Minimize">
      <summary />
    </member>
    <member name="F:Optimization.ObjectiveSense.Maximize">
      <summary />
    </member>
    <member name="T:Optimization.Solver.BranchAndBound">
      <summary>
              Solves a model with the Branch and Bound method.
              Requires implementation of interface IHandler
            </summary>
      <author>dlueers</author>
    </member>
    <member name="T:Optimization.Solver.BranchAndBound.IHandler">
      <summary>
              IHandler interface to implement for BranchAndBound Solver
            </summary>
    </member>
    <member name="M:Optimization.Solver.BranchAndBound.IHandler.GetBranches(Optimization.Model,Optimization.Solution)">
      <summary>
              Computes the constraints for the next branching step at this solution.
            </summary>
      <param name="model">Original model.</param>
      <param name="solution">Current solution.</param>
      <returns>Constraints to add for each new branch.</returns>
    </member>
    <member name="M:Optimization.Solver.BranchAndBound.IHandler.SelectNextNode(System.Collections.Generic.IList{Optimization.Solver.BranchAndBound.Node})">
      <summary>
              Selects the next node out of the list of remaining nodes.
            </summary>
      <param name="list">List of open nodes.</param>
      <returns>Next node.</returns>
    </member>
    <member name="M:Optimization.Solver.BranchAndBound.IHandler.GetRelaxedModel(Optimization.Model)">
      <summary>
              Computes the relaxation of the model.
            </summary>
      <returns>Relaxed model.</returns>
    </member>
    <member name="M:Optimization.Solver.BranchAndBound.IHandler.Terminate(System.Double,System.Nullable{System.Double},System.Int32)">
      <summary>
            Decides whether to terminate the branch and bound algorithm.
            </summary>
      <param name="incumbentObjectiveValue">The incumbent objective value.</param>
      <param name="currentObjectiveValue">The current objective value.</param>
      <param name="numberOfOpenNodes">The number of open nodes.</param>
      <returns />
    </member>
    <member name="M:Optimization.Solver.BranchAndBound.IHandler.NewIncumbentFoundEvent(Optimization.Solution)">
      <summary>
              Method, which is called, if the Branch and Bound found a new incumbent.
            </summary>
      <param name="newIncumbent" />
    </member>
    <member name="T:Optimization.Solver.BranchAndBound.Node">
      <summary>
              Represents a node in the Branch and Bound Tree.
            </summary>
    </member>
    <member name="M:Optimization.Solver.BranchAndBound.Node.#ctor(Optimization.Solver.BranchAndBound.Node,System.Collections.Generic.ISet{Optimization.Constraint})">
      <summary>
              Initializes a new instance of the <see cref="T:Optimization.Solver.BranchAndBound.Node" /> class.
            </summary>
      <param name="parent">The parent.</param>
      <param name="additionalConstraints">The additional constraints.</param>
    </member>
    <member name="P:Optimization.Solver.BranchAndBound.Node.VariableValues">
      <summary>
            Gets or sets the variable values, which represent the solution to the model represented by this node.
            </summary>
      <value>
            The variable values.
            </value>
    </member>
    <member name="P:Optimization.Solver.BranchAndBound.Node.ObjectiveValue">
      <summary>
            Gets or sets the objective value of this node.
            </summary>
      <value>
            The objective value.
            </value>
    </member>
    <member name="P:Optimization.Solver.BranchAndBound.Node.Parent">
      <summary>
            Gets the parent node.
            </summary>
    </member>
    <member name="P:Optimization.Solver.BranchAndBound.Node.AdditionalConstraints">
      <summary>
            Gets the additional constraints. These constraints are additional to the root model.
            </summary>
    </member>
    <member name="M:Optimization.Solver.BranchAndBound.#ctor(Optimization.Solver.BranchAndBound.IHandler,Optimization.Interfaces.ISolver)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.BranchAndBound" /> class.
            </summary>
      <param name="handler">The handler.</param>
      <param name="solver">The solver that solves a node.</param>
    </member>
    <member name="M:Optimization.Solver.BranchAndBound.GetCurrentModel(Optimization.Solver.BranchAndBound.Node)">
      <summary>
              Builds model for current node.
            </summary>
      <param name="current">Current node.</param>
      <returns>Model for current node.</returns>
    </member>
    <member name="M:Optimization.Solver.BranchAndBound.CreateChildren(Optimization.Solver.BranchAndBound.Node,System.Collections.Generic.IEnumerable{System.Collections.Generic.ISet{Optimization.Constraint}})">
      <summary>
              Creates children of current node and adds them to openNodes-List.
            </summary>
      <param name="parent">Current node.</param>
      <param name="branches">Constraints for the branches.</param>
    </member>
    <member name="T:Optimization.Solver.ICanProveFeasibility">
      <summary>
              A class implementing this interface is able to prove that variable values are a feasible solution to a model.
            </summary>
    </member>
    <member name="M:Optimization.Solver.ICanProveFeasibility.Prove(Optimization.Model,System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
              Proves that the provided variable values are a feasible solution for the model.
            </summary>
      <param name="model">The model.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.AddConstraint(Optimization.Constraint)">
      <summary>
            Adds the constraint.
            </summary>
      <param name="constraint">The constraint.</param>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.AddVariable(Optimization.Interfaces.IVariable)">
      <summary>
            Adds the variable.
            </summary>
      <param name="variable">The variable.</param>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.RemoveConstraint(System.String)">
      <summary>
            Removes the constraint.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.RemoveVariable(System.String)">
      <summary>
            Removes the variable.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.AddObjective(Optimization.Objective)">
      <summary>
            Adds the objective.
            </summary>
      <param name="objective">The objective.</param>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.RemoveObjective">
      <summary>
            Removes the objective.
            </summary>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.ChangeVariableLowerBound(System.String,System.Double)">
      <summary>
            Changes the variable lower bound.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerbound">The lowerbound.</param>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.ChangeVariableUpperBound(System.String,System.Double)">
      <summary>
            Changes the variable upper bound.
            </summary>
      <param name="name">The name.</param>
      <param name="upperbound">The upperbound.</param>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.ChangeVariableType(System.String,Optimization.VariableType)">
      <summary>
            Changes the type of the variable.
            </summary>
      <param name="name">The name.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.ChangeConstraintLowerBound(System.String,System.Double)">
      <summary>
            Changes the constraint lower bound.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerbound">The lowerbound.</param>
    </member>
    <member name="M:Optimization.Solver.Interfaces.ICanManipulateANativeSolver.ChangeConstraintUpperBound(System.String,System.Double)">
      <summary>
            Changes the constraint upper bound.
            </summary>
      <param name="name">The name.</param>
      <param name="upperbound">The upperbound.</param>
    </member>
    <member name="M:Optimization.Interfaces.ICanRegisterSolvers.Unregister(Optimization.Solver.Interfaces.ICanManipulateANativeSolver)">
      <summary>
            Unregisters the specified solver.
            </summary>
      <param name="solver">The solver.</param>
    </member>
    <member name="M:Optimization.Interfaces.ICanRegisterSolvers.Register(Optimization.Solver.Interfaces.ICanManipulateANativeSolver)">
      <summary>
            Registers the specified solver to work on this problem
            </summary>
      <param name="solver">The solver.</param>
    </member>
    <member name="T:Optimization.Interfaces.IModel">
      <summary>
            Represents a mathematical programming problem.
            Supports mixed integer non-linear programming problems with multiple objectives and stochastic.
            </summary>
      <author>fseidel, skramkowski, lbeckmann</author>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddVariable(Optimization.Interfaces.IVariable)">
      <summary>
            Adds <paramref name="variable" /> to this model instance if it is consistent.
            </summary>
      <param name="variable">Variable to add.</param>
      <requires csharp="variable != null" vb="variable &lt;&gt; Nothing">variable != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddVariable(System.String,System.Double,System.Double,Optimization.VariableType)">
      <summary>
            Adds a new variable to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new variable.</param>
      <param name="lowerBound">Lower bound of the new variable.</param>
      <param name="upperBound">Upper bound of the new variable.</param>
      <param name="type">Type of the new variable.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddSOS1(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double})">
      <summary>
            Adds an SOS1 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddSOS2(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double})">
      <summary>
            Adds an SOS2 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddSOS3(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double})">
      <summary>
            Adds an SOS3 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddSOS(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double},Optimization.SOSType)">
      <summary>
            Adds an SOS Constraint of the given SOSType
            </summary>
      <param name="variables">The variables.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddConstraint(Optimization.Constraint,System.String)">
      <summary>
            Adds <paramref name="constraint" /> to this model instance if it is consistent. If you choose to provide a name, the name of the constraint will be overridden.
            You need to make sure that the name of the constraint is unique.
            </summary>
      <param name="constraint">Constraint to add.</param>
      <param name="name">The name for the constraint</param>
      <requires csharp="constraint != null" vb="constraint &lt;&gt; Nothing">constraint != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddConstraint(System.String,System.Double,System.Double,Optimization.Expression)">
      <summary>
            Adds a new constraint to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new constraint.</param>
      <param name="lowerBound">Lower bound (left hand side) of the new constraint.</param>
      <param name="upperBound">Upper bound (right hand side) of the new constraint.</param>
      <param name="expression">Expression of the new constraint.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddObjective(Optimization.Objective)">
      <summary>
            Adds <paramref name="objective" /> to this model instance if it is consistent.
            </summary>
      <param name="objective">Objective to add.</param>
      <requires csharp="objective != null" vb="objective &lt;&gt; Nothing">objective != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddObjective(Optimization.Expression,System.String,Optimization.ObjectiveSense)">
      <summary>
            Adds a new objective to this model instance if it is consistent.
            </summary>
      <param name="expression">Expression of the new objective.</param>
      <param name="name">Unique name of the new objective.</param>
      <param name="sense">Sense of the new objective.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddVariables(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IVariable})">
      <summary>
            Adds a set of variables to this model instance if it is consistent.
            </summary>
      <param name="variables">Set of variables to add.</param>
      <requires csharp="variables != null" vb="variables &lt;&gt; Nothing">variables != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddConstraints(System.Collections.Generic.IEnumerable{Optimization.Constraint})">
      <summary>
            Adds a set of constraint to this model instance if it is consistent.
            </summary>
      <param name="constraints">Set of constraints to add.</param>
      <requires csharp="constraints != null" vb="constraints &lt;&gt; Nothing">constraints != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddAlternativeConstraintGroups(System.Collections.Generic.IEnumerable{Optimization.Constraint},System.Collections.Generic.IEnumerable{Optimization.Constraint},System.Double)">
      <summary>
            OR connects the constraints from group1 with the constraints from group2
            </summary>
      <param name="group1">The first constraint group.</param>
      <param name="group2">The second constraint group.</param>
      <param name="bigM">A number as small as possible, so that no constraint is limited by this number</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddAlternativeConstraints(System.Collections.Generic.IEnumerable{Optimization.Constraint},System.Double)">
      <summary>
            Adds the constraints to the model. The contained constraints will be OR connected -&gt; at least one constraint must be true
            </summary>
      <param name="constraints">The constraints.</param>
      <param name="bigM">A number as small as possible, so that no constraint is limited by this number</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddObjectives(System.Collections.Generic.IEnumerable{Optimization.Objective})">
      <summary>
            Adds a set of objectives to this model instance if it is consistent.
            </summary>
      <param name="objectives">Set of objectives to add.</param>
      <requires csharp="objectives != null" vb="objectives &lt;&gt; Nothing">objectives != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.Clear">
      <summary>
            Removes all variables, constraints, objectives and scenarios from this model instance.
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.IModel.ContainsVariable(System.String)">
      <summary>
            Contains this model instance a variable named <paramref name="name" />?
            </summary>
      <param name="name">Name of the variable to search for.</param>
      <returns />
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.ContainsConstraint(System.String)">
      <summary>
            Contains this model instance a constraint named <paramref name="name" />?
            </summary>
      <param name="name">Name of the constraint to search for.</param>
      <returns />
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.ContainsObjective(System.String)">
      <summary>
            Contains this model instance an objective named <paramref name="name" />?
            </summary>
      <param name="name">Name of the objective to search for.</param>
      <returns />
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.GetVariable(System.String)">
      <summary>
            Returns the variable named <paramref name="name" />, or <c>null</c> if this model instance contains no such variable.
            </summary>
      <param name="name">Name of the variable to search for.</param>
      <returns />
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.GetConstraint(System.String)">
      <summary>
            Returns the constraint named <paramref name="name" />, or <c>null</c> if this model instance contains no such constraint.
            </summary>
      <param name="name">Name of the constraint to search for.</param>
      <returns />
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.GetObjective(System.String)">
      <summary>
            Returns the objective named <paramref name="name" />, or <c>null</c> if this model instance contains no such objective.
            </summary>
      <param name="name">Name of the objective to serach for.</param>
      <returns />
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveVariable(System.String)">
      <summary>
            Removes the variable named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such variable.
            </summary>
      <param name="name">Name of the variable to remove.</param>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveConstraint(System.String)">
      <summary>
            Removes the constraint named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such constraint.
            </summary>
      <param name="name">Name of the constraint to remove.</param>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveObjective(System.String)">
      <summary>
            Removes the objective named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such objective.
            </summary>
      <param name="name">Name of the objective to remove.</param>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveVariables(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of variables from this model instance.
            </summary>
      <param name="names">Names of the variables to remove.</param>
      <requires csharp="names != null" vb="names &lt;&gt; Nothing">names != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveConstraints(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of constraints from this model instance.
            </summary>
      <param name="names">Names of the constraints to remove.</param>
      <requires csharp="names != null" vb="names &lt;&gt; Nothing">names != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveObjectives(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of objectives from this model instance.
            </summary>
      <param name="names">Names of the objectives to remove.</param>
      <requires csharp="names != null" vb="names &lt;&gt; Nothing">names != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.Load(System.IO.Stream)">
      <summary>
            Loads the specified file with the specified filetype.
            </summary>
      <param name="filestream">The filestream.</param>
      <requires csharp="filestream != null" vb="filestream &lt;&gt; Nothing">filestream != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.Write(System.IO.Stream,Optimization.FileType)">
      <summary>
            Writes the model to the specified filestream.
            </summary>
      <param name="filestream">The filestream.</param>
      <param name="fileType">Type of the file.</param>
      <requires csharp="filestream != null" vb="filestream &lt;&gt; Nothing">filestream != null</requires>
    </member>
    <member name="P:Optimization.Interfaces.IModel.Name">
      <summary>
            Name of this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.ModelBehavior">
      <summary>
            Gets or sets the behavior of the model. Available options are "Automatic" and "Manual"
            In automatic mode, the model takes care of adding and removing variables when constraints and objectives get added. In manual mode you need to take care of this yourself.
            </summary>
      <value>The model behavior.</value>
    </member>
    <member name="P:Optimization.Interfaces.IModel.Variables">
      <summary>
            Variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.SOS1Sets">
      <summary>
            Sets of SOS1 variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.SOS2Sets">
      <summary>
            Sets of SOS2 variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.SOS3Sets">
      <summary>
            Sets of SOS3 variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.Constraints">
      <summary>
            Constraints in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.Objectives">
      <summary>
            Objectives in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.VariablesCount">
      <summary>
            Count of variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.ConstraintsCount">
      <summary>
            Count of constraints in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.ObjectivesCount">
      <summary>
            Count of objectives in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.AreAllVariablesBinary">
      <summary>
            Are all variables in this model instance of type integer and their lower bound equal to zero and their upper bound equal to 1?
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.AreAllVariablesInteger">
      <summary>
            Are all variables in this model instance of type integer?
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.AreAllVariablesContinuous">
      <summary>
            Are variables in this model instance of type continuous?
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.AreAllConstraintsLinear">
      <summary>
            Have all constraints in this model instance linear expressions?
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.AreAllObjectivesLinear">
      <summary>
            Have all objectives in this model instance linear expressions?
            </summary>
    </member>
    <member name="T:Optimization.Operators.Interfaces.IOperatorExpression">
      <summary>
            Any operation (Plus, Times, etc.) that wants to be exposed as an expression needs to implement this interface
            </summary>
    </member>
    <member name="P:Optimization.Operators.Interfaces.IOperatorExpression.Expressions">
      <summary>
            Gets the expressions.
            </summary>
    </member>
    <member name="T:Optimization.Model">
      <summary>
            Represents a mathematical model
            </summary>
    </member>
    <member name="M:Optimization.Model.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Model" /> class.
            </summary>
    </member>
    <member name="M:Optimization.Model.AddVariable(Optimization.Interfaces.IVariable)">
      <summary>
            Adds <paramref name="variable" /> to this model instance if it is consistent.
            </summary>
      <param name="variable">Variable to add.</param>
    </member>
    <member name="M:Optimization.Model.AddVariable(System.String,System.Double,System.Double,Optimization.VariableType)">
      <summary>
            Adds a new variable to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new variable.</param>
      <param name="lowerBound">Lower bound of the new variable.</param>
      <param name="upperBound">Upper bound of the new variable.</param>
      <param name="type">Type of the new variable.</param>
    </member>
    <member name="M:Optimization.Model.AddConstraint(Optimization.Constraint,System.String)">
      <summary>
            Adds <paramref name="constraint" /> to this model instance if it is consistent. If you choose to provide a name, the name of the constraint will be overridden.
            You need to make sure that the name of the constraint is unique.
            </summary>
      <param name="constraint">Constraint to add.</param>
      <param name="name">The name for the constraint</param>
    </member>
    <member name="M:Optimization.Model.AddConstraint(Optimization.Operators.OperatorConstraint)">
      <summary>
            Adds <paramref name="operatorConstraint" /> to the OperatorConstraints in the model.
            </summary>
      <param name="operatorConstraint">The OperatorConstraint (Not, Or, Where).</param>
    </member>
    <member name="M:Optimization.Model.AddConstraint(System.String,System.Double,System.Double,Optimization.Expression)">
      <summary>
            Adds a new constraint to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new constraint.</param>
      <param name="lowerBound">Lower bound (left hand side) of the new constraint.</param>
      <param name="upperBound">Upper bound (right hand side) of the new constraint.</param>
      <param name="expression">Expression of the new constraint.</param>
    </member>
    <member name="M:Optimization.Model.AddObjective(Optimization.Objective)">
      <summary>
            Adds <paramref name="objective" /> to this model instance if it is consistent.
            </summary>
      <param name="objective">Objective to add.</param>
    </member>
    <member name="M:Optimization.Model.AddObjective(Optimization.Expression,System.String,Optimization.ObjectiveSense)">
      <summary>
            Adds a new objective to this model instance if it is consistent.
            </summary>
      <param name="expression">Expression of the new objective.</param>
      <param name="name">Unique name of the new objective.</param>
      <param name="sense">Sense of the new objective.</param>
    </member>
    <member name="M:Optimization.Model.AddVariables(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IVariable})">
      <summary>
            Adds a set of variables to this model instance if it is consistent. //TODO: discuss: What do we mean by "consistent"?
            </summary>
      <param name="variables">Set of variables to add.</param>
    </member>
    <member name="M:Optimization.Model.AddConstraints(System.Collections.Generic.IEnumerable{Optimization.Constraint})">
      <summary>
            Adds a set of constraint to this model instance if it is consistent.
            </summary>
      <param name="constraints">Set of constraints to add.</param>
    </member>
    <member name="M:Optimization.Model.AddAlternativeConstraintGroups(System.Collections.Generic.IEnumerable{Optimization.Constraint},System.Collections.Generic.IEnumerable{Optimization.Constraint},System.Double)">
      <summary>
            Adds two groups of constraints. Either group1 or group2 or both have to be fulfilled.
            </summary>
      <param name="group1">The group1.</param>
      <param name="group2">The group2.</param>
      <param name="bigM">The big M.</param>
    </member>
    <member name="M:Optimization.Model.AddAlternativeConstraints(System.Collections.Generic.IEnumerable{Optimization.Constraint})">
      <summary>
            Adds constraints that are OR concatenated. That means that at least one of these constraints have to be fulfilled.
            For every constraint l&lt;=exp&lt;=u in constraints this method will add the following two constraints to your model:
            -exp-bigM*(1-z1)&lt;=-l
            exp-bigM*(1-z1)&lt;=u
            where z is a binary variable indicating that this constraint is active (has to be fulfilled).
            Since this will happen for every constraint in the list of constraints, the binary variables z will be summed up in one additional constraint, such that Expression.Sum(z1,...,zn)&gt;1
            The bigM will be computed for you, but this can only happen when you provide finite bounds on all variables that are used in your constraints.
            </summary>
      <param name="constraints">The constraints.</param>
      <requires description="The variables used in your constraints have to have finite bounds." csharp="All&lt;Optimization.Constraint&gt;(constraints, (Optimization.Constraint constraint) =&gt; All&lt;Optimization.Term&gt;(constraint.Expression.Terms, delegate (Optimization.Term term) {&#xD;&#xA;    if (!(term.Factor &gt; 0.0))&#xD;&#xA;    {&#xD;&#xA;        return term.Variable.LowerBound &gt; double.NegativeInfinity;&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;    return term.Variable.UpperBound &lt; double.PositiveInfinity;&#xD;&#xA;&#xD;&#xA;}))" vb="All(constraints, (constraint As Optimization.Constraint) =&gt; All(constraint.Expression.Terms, delegate (term As Optimization.Term) {&#xD;&#xA;    If !(term.Factor &gt; 0 Then&#xD;&#xA;    Return term.Variable.LowerBound &gt; -unendlich&#xD;&#xA;    Return term.Variable.UpperBound &lt; +unendlich&#xD;&#xA;}))">System.Linq.Enumerable.All&lt;Optimization.Constraint&gt;(constraints, (Optimization.Constraint constraint) =&gt; System.Linq.Enumerable.All&lt;Optimization.Term&gt;(constraint.Expression.Terms, delegate (Optimization.Term term) {
    if (!(term.Factor &gt; 0.0))
    {
        return term.Variable.LowerBound &gt; double.NegativeInfinity;

    }
    return term.Variable.UpperBound &lt; double.PositiveInfinity;

}))</requires>
      <requires csharp="All&lt;Optimization.Constraint&gt;(constraints, delegate (Optimization.Constraint constraint) {&#xD;&#xA;    if (constraint.LowerBound != double.NegativeInfinity)&#xD;&#xA;    {&#xD;&#xA;        return true;&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;    return constraint.UpperBound != double.PositiveInfinity;&#xD;&#xA;&#xD;&#xA;})" vb="All(constraints, delegate (constraint As Optimization.Constraint) {&#xD;&#xA;    If constraint.LowerBound &lt;&gt; -unendlich Then&#xD;&#xA;    Return True&#xD;&#xA;    Return constraint.UpperBound &lt;&gt; +unendlich&#xD;&#xA;})">System.Linq.Enumerable.All&lt;Optimization.Constraint&gt;(constraints, delegate (Optimization.Constraint constraint) {
    if (constraint.LowerBound != double.NegativeInfinity)
    {
        return true;

    }
    return constraint.UpperBound != double.PositiveInfinity;

})</requires>
    </member>
    <member name="M:Optimization.Model.AddAlternativeConstraints(System.Collections.Generic.Dictionary{Optimization.Constraint,System.Double})">
      <summary>
            Adds constraints that are OR concatenated. That means that at least one of these constraints have to be fulfilled.
            For every constraint l&lt;=exp&lt;=u in constraints this method will add the following two constraints to your model:
            -exp-bigM*(1-z1)&lt;=-l
            exp-bigM*(1-z1)&lt;=u
            where z is a binary variable indicating that this constraint is active (has to be fulfilled).
            Since this will happen for every constraint in the list of constraints, the binary variables z will be summed up in one additional constraint, such that Expression.Sum(z1,...,zn)&gt;1
            For each constraint you will have to provide a bigM value.
            </summary>
      <param name="constraintBigMPairs">The constraints and a bigM for each of them.</param>
    </member>
    <member name="M:Optimization.Model.AddObjectives(System.Collections.Generic.IEnumerable{Optimization.Objective})">
      <summary>
            Adds a set of objectives to this model instance if it is consistent.
            </summary>
      <param name="objectives">Set of objectives to add.</param>
    </member>
    <member name="M:Optimization.Model.Clear">
      <summary>
            Removes all variables, constraints, objectives and scenarios from this model instance.
            </summary>
    </member>
    <member name="M:Optimization.Model.ContainsVariable(System.String)">
      <summary>
            Contains this model instance a variable named <paramref name="name" />?
            </summary>
      <param name="name">Name of the variable to search for.</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.ContainsConstraint(System.String)">
      <summary>
            Contains this model instance a constraint named <paramref name="name" />?
            </summary>
      <param name="name">Name of the constraint to search for.</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.ContainsObjective(System.String)">
      <summary>
            Contains this model instance an objective named <paramref name="name" />?
            </summary>
      <param name="name">Name of the objective to search for.</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.GetVariable(System.String)">
      <summary>
            Returns the variable named <paramref name="name" />, or <c>null</c> if this model instance contains no such variable.
            </summary>
      <param name="name">Name of the variable to search for.</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.GetConstraint(System.String)">
      <summary>
            Returns the constraint named <paramref name="name" />, or <c>null</c> if this model instance contains no such constraint.
            </summary>
      <param name="name">Name of the constraint to search for.</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.GetObjective(System.String)">
      <summary>
            Returns the objective named <paramref name="name" />, or <c>null</c> if this model instance contains no such objective.
            </summary>
      <param name="name">Name of the objective to serach for.</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.RemoveVariable(System.String)">
      <summary>
            Removes the variable named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such variable.
            </summary>
      <param name="name">Name of the variable to remove.</param>
    </member>
    <member name="M:Optimization.Model.RemoveConstraint(System.String)">
      <summary>
            Removes the constraint named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such constraint.
            </summary>
      <param name="name">Name of the constraint to remove.</param>
    </member>
    <member name="M:Optimization.Model.RemoveObjective(System.String)">
      <summary>
            Removes the objective named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such objective.
            </summary>
      <param name="name">Name of the objective to remove.</param>
    </member>
    <member name="M:Optimization.Model.RemoveVariables(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of variables from this model instance.
            </summary>
      <param name="names">Names of the variables to remove.</param>
    </member>
    <member name="M:Optimization.Model.RemoveConstraints(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of constraints from this model instance.
            </summary>
      <param name="names">Names of the constraints to remove.</param>
    </member>
    <member name="M:Optimization.Model.RemoveObjectives(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of objectives from this model instance.
            </summary>
      <param name="names">Names of the objectives to remove.</param>
    </member>
    <member name="M:Optimization.Model.Load(System.IO.Stream,Optimization.FileType)">
      <summary>
            Loads the specified file in the specified format and adds the content to the current model
            </summary>
      <param name="filestream">The filestream.</param>
      <param name="fileType">The file type (lp or mps)</param>
    </member>
    <member name="M:Optimization.Model.Write(System.IO.Stream,Optimization.FileType)">
      <summary>
            Writes the model to the specified filestream.
            </summary>
      <param name="filestream">The filestream.</param>
      <param name="fileType">Type of the file.</param>
    </member>
    <member name="M:Optimization.Model.AddSOS1(System.Collections.Generic.Dictionary{Optimization.Variable,System.Double})">
      <summary>
            Adds an SOS1 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Model.AddSOS2(System.Collections.Generic.Dictionary{Optimization.Variable,System.Double})">
      <summary>
            Adds an SOS2 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Model.AddSOS3(System.Collections.Generic.Dictionary{Optimization.Variable,System.Double})">
      <summary>
            Adds an SOS3 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Model.automaticAddingOfVariables(Optimization.Expression)">
      <requires csharp="expression != null" vb="expression &lt;&gt; Nothing">expression != null</requires>
      <requires csharp="expression.Variables != null" vb="expression.Variables &lt;&gt; Nothing">expression.Variables != null</requires>
    </member>
    <member name="M:Optimization.Model.automaticRemovingOfVariables(Optimization.Expression)">
      <requires csharp="expression != null" vb="expression &lt;&gt; Nothing">expression != null</requires>
      <requires csharp="expression.Variables != null" vb="expression.Variables &lt;&gt; Nothing">expression.Variables != null</requires>
    </member>
    <member name="M:Optimization.Model.AddSOS(System.Collections.Generic.Dictionary{Optimization.Variable,System.Double},Optimization.SOSType)">
      <summary>
            Adds an SOS Constraint of the given SOSType
            </summary>
      <param name="variables">The variables.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Optimization.Model.Ceil(Optimization.Expression)">
      <summary>
            Returns an Expression object respresenting the ceil roundoff of the specified expression.
            </summary>
      <param name="expression">The expression.</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.Floor(Optimization.Expression)">
      <summary>
            Returns an Expression object respresenting the floor roundoff of the specified expression.
            </summary>
      <param name="expression">The expression.</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.Abs(Optimization.Expression,System.Double)">
      <summary>
            Returns an Expression object respresenting the absolute value of the specified expression.
            </summary>
      <param name="expression">The expression.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.Abs(Optimization.Term,System.Double)">
      <summary>
            Returns an Expression object respresenting the absolute value of the specified expression.
            </summary>
      <param name="expression">The expression.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.Min(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Double)">
      <summary>
            Returns an Expression object respresenting the minimum of the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.Max(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Double)">
      <summary>
            Returns an Expression object representing the maximum of the specified expresssions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <returns />
    </member>
    <member name="P:Optimization.Model.Name">
      <summary>
            Name of this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.ModelBehavior">
      <summary>
            Gets or sets the behavior of the model. Available options are "Automatic" and "Manual"
            In automatic mode, the model takes care of adding and removing variables when constraints and objectives get added. In manual mode you need to take care of this yourself.
            </summary>
      <value>
            The model behavior.
            </value>
    </member>
    <member name="P:Optimization.Model.NotifySolversIfModelChanges">
      <summary>
            If set to true (standard value), will communicate the changes made to this model directly to all solver instances that have previously solved this model.
            </summary>
      <value>
        <c>true</c> if model should notify all solvers; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Optimization.Model.Variables">
      <summary>
            Variables in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.SOS1Sets">
      <summary>
            Sets of SOS1 variables in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.SOS2Sets">
      <summary>
            Sets of SOS2 variables in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.SOS3Sets">
      <summary>
            Sets of SOS3 variables in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.Constraints">
      <summary>
            Constraints in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.Objectives">
      <summary>
            Objectives in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.VariablesCount">
      <summary>
            Count of variables in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.ConstraintsCount">
      <summary>
            Count of constraints in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.ObjectivesCount">
      <summary>
            Count of objectives in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.AreAllVariablesBinary">
      <summary>
            Are all variables in this model instance of type integer and their lower bound equal to zero and their upper bound equal to 1?
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.AreAllVariablesInteger">
      <summary>
            Are all variables in this model instance of type integer?
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.AreAllVariablesContinuous">
      <summary>
            Are variables in this model instance of type continuous?
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.AreAllConstraintsLinear">
      <summary>
            Have all constraints in this model instance linear expressions?
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.AreAllObjectivesLinear">
      <summary>
            Have all objectives in this model instance linear expressions?
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.OperatorConstraints">
      <summary>
            Constraints in this model instance.
            </summary>
      <value />
    </member>
    <member name="T:Optimization.ModelTransformation">
      <summary>
            A ModelTransformation offers functionality to transform a model that contains special OperatorExpressions 
            as, e.g., Max,Min,Abs,Floor,Ceil  into a model where these expressions vanish in the sense that they are modelled
             through new variables and constraints.
            This transformation may re-establish linearity of the model.
            TODO: implement a  handling of minmax or maxmin cases in ojectives and constraints. 
            --&gt; Store objective type as global variable and make a distinction of cases!!!
            </summary>
    </member>
    <member name="F:Optimization.ModelTransformation.internalmodel">
      <summary>
            global variable for the changed model that will be returned by Transform(IModel)
            </summary>
    </member>
    <member name="M:Optimization.ModelTransformation.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.ModelTransformation" /> class.
            </summary>
    </member>
    <member name="M:Optimization.ModelTransformation.Transform(Optimization.Model)">
      <summary>
            Transform the input model containing OperatorExpressions as, e.g., Min into a new model where these expressions are 
            replaced by new variables and constraints. This means that in the original model also some implicit variables marking 
            new representing variables are set. Modelbehavior of the resulting model is set to Auto.
            </summary>
      <param name="originalmodel">The original model</param>
      <returns>The new model</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.TransformConstraint(Optimization.Constraint)">
      <summary>
            Transforms a single constraint recursively by replacing special operator expressions by new variables and
             adding new constraints to internalmodel. 
            </summary>
      <param name="constraint">The constraint</param>
      <returns>The constraint with replaced components</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.TransformOperatorConstraint(Optimization.Operators.OperatorConstraint)">
      <summary>
            Transforms a single <see cref="T:Optimization.Operators.OperatorConstraint" /> into a List of Constraints.
            </summary>
      <param name="constraint">The OperatorConstraint</param>
      <returns />
    </member>
    <member name="M:Optimization.ModelTransformation.VisitNot(Optimization.Operators.Not)">
      <summary>
            Transforms a <see cref="T:Optimization.Operators.Not" /> into a list of Constraints representing a the negated Constraint.
            </summary>
      <param name="notOperator" />
      <returns />
    </member>
    <member name="M:Optimization.ModelTransformation.VisitOr(Optimization.Operators.Or)">
      <summary>
            Transforms an <see cref="T:Optimization.Operators.Or" /> into a list of Constraints to form an or condition.
            </summary>
      <param name="or">The or</param>
      <returns />
    </member>
    <member name="M:Optimization.ModelTransformation.VisitWhere(Optimization.Operators.Where)">
      <summary>
            Transforms a <see cref="T:Optimization.Operators.Where" /> into a list of Constraints to form a where.
            </summary>
      <param name="where" />
      <returns />
    </member>
    <member name="M:Optimization.ModelTransformation.AddAlternativeConstraints(Optimization.Constraint,System.Collections.Generic.List{Optimization.Variable},System.Collections.Generic.List{Optimization.Constraint},Optimization.Variable)">
      <requires description="Only an infinite-BigM could be computed. Please try to replace infinite variable-bounds with bounded ones." csharp="constraint.Expression.BigM != double.PositiveInfinity" vb="constraint.Expression.BigM &lt;&gt; +unendlich">constraint.Expression.BigM != double.PositiveInfinity</requires>
    </member>
    <member name="M:Optimization.ModelTransformation.TransformObjective(Optimization.Objective)">
      <summary>
            Transforms a single objective recursively by replacing special operator expressions by new variables and
             adding new constraints to internalmodel. 
            </summary>
      <param name="objective">The objective</param>
      <returns>The objective with replaced components</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.Visit(Optimization.Expression)">
      <summary>
            Visitor for expressions, i.e., here the expression of a constraint is walked through recursively and replacements 
            are performed
            </summary>
      <param name="exp">The expression</param>
      <returns>The expression with replaced components</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitPlus(Optimization.Operators.Interfaces.IPlus)">
      <summary>
            Visitor for Plus
            </summary>
      <param name="plus">A Plus OperatorExpression</param>
      <returns>A Plus-Expression with replaced components</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitTimes(Optimization.Operators.Interfaces.ITimes)">
      <summary>
            Visitor for Times.
            </summary>
      <param name="times">A Times OperatorExpression</param>
      <returns>A Times-Expression with replaced components </returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitConstant(Optimization.ConstantExpression)">
      <summary>
            Visitor for Constant. This method is just a dummy and returns the input.
            </summary>
      <param name="constantExpression">the constant expression</param>
      <returns>the input constantExpression</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitTerm(Optimization.Term)">
      <summary>
            Visitor for Term. This method is just a dummy and returns the input
            </summary>
      <param name="term">the term</param>
      <returns>the input term</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitMax(Optimization.Operators.Interfaces.IMax)">
      <summary>
            Visit a Max OperatorExpression and replace it by a new variable and the constraints that will
            be included in internalmodel. The representing variable of the Max object will be set and in case of a max of more than
            two expressions a reformulation in terms of a recursion of two-arguments max-expressions is performed. 
            TODO: For the resulting implicit max-Expressions only the representing variable on the highest level is stored yet
            ---&gt; find a solution telling the user about every new variable . 
            </summary>
      <param name="max">The Max object</param>
      <returns>The expression with replaced terms</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.maxOfAllowedExpressionsDC(Optimization.Variable,System.Collections.Generic.IEnumerable{Optimization.Expression},System.Double)">
      <summary>
            Helper routine for VisitMax. recursivley reformulate z = max(argumentexpressions) by a divide and conquer Ansatz
            until only max-expressions of two arguments are left. If possible, bounds on the 
            representing variables are inherited from the corresponding expressions. If not :
            Attention: Any expression that can not be estimated by finite bounds will receive bounds double.NegativeInfinity and 
            double.PositiveInfinity.
            Todo: In that case the new constraints will work with the constants +/- double.MaxValue!!!
            ToDo: Using skip and take for the division is dirty. IEnumerable does not guarantee ordering 
            -&gt; potentially use Except to make sure no element was used twice
            </summary>
      <param name="z">the representing variable for the max object in this call</param>
      <param name="argumentexpressions">the arguments of the corresponding max in this call</param>
      <param name="bigM">Large number, used if the bounds of the variables of the expressions are non-finite</param>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitMin(Optimization.Operators.Interfaces.IMin)">
      <summary>
            Visit a Min OperatorExpression and replace it by a new variable and the constraints that will
            be included in internalmodel. The representing variable of the Min object will be set and in case of a min of more than
            two expressions a reformulation in terms of a recursion of two-arguments min-expressions is performed. 
            TODO: For the resulting implicit min-Expressions only the representing variable on the highest level is stored yet
            ---&gt; find a solution telling the user about every new variable . 
            </summary>
      <param name="min">The Min object</param>
      <returns>The expression with replaced terms</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.minOfAllowedExpressionsDC(Optimization.Variable,System.Collections.Generic.IEnumerable{Optimization.Expression},System.Double)">
      <summary>
            Helper routine for VisitMin. recursivley reformulate z = min(argumentexpressions) by a divide and conquer Ansatz
            until only min-expressions of two arguments are left. If possible, bounds on the 
            representing variables are inherited from the corresponding expressions. If not :
            Attention: Any expression that can not be estimated by finite bounds will receive bounds double.NegativeInfinity and 
            double.PositiveInfinity.
            Todo: In that case the new constraints will work with the constants +/- double.MaxValue!!!
            ToDo: Using skip and take for the division is dirty. IEnumerable does not guarantee ordering -&gt; potentially use Except to make sure no element was used twice
            </summary>
      <param name="z">the representing variable for the min object in this call</param>
      <param name="argumentexpressions">the arguments of the corresponding min in this call</param>
      <param name="bigM">Large number, used if the bounds of the variables of the expressions are non-finite</param>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitAbs(Optimization.Operators.Interfaces.IAbs)">
      <summary>
            Visit an Abs OperatorExpression and replace it by a new variable and the constraints that will
            be included in internalmodel. The representing variable of the Abs object will be set.
            If possible, bounds on the representing variable are inherited from the corresponding expression. 
            Todo: Attention: In case of infinite bounds, constraints are added with double.MaxValue instead of infinite constants
            </summary>
      <param name="abs">The Abs object</param>
      <returns>The expression with replaced terms</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitFloor(Optimization.Operators.Interfaces.IFloor)">
      <summary>
            Visit a Floor OperatorExpression and replace it by a new variable and the constraints that will
            be included in internalmodel. The representing variable of the Floor object will be set
            </summary>
      <param name="floor">The Floor object</param>
      <returns>The expression with replaced terms</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitCeil(Optimization.Operators.Interfaces.ICeil)">
      <summary>
            Visit a Ceil OperatorExpression and replace it by a new variable and the constraints that will
            be included in internalmodel. The representing variable of the Ceil object will be set
            </summary>
      <param name="ceil">The ceil object</param>
      <returns>The expression with replaced terms</returns>
    </member>
    <member name="T:Optimization.Objective">
      <summary>
            Represents an objective
            </summary>
      <author>lbeckmann</author>
    </member>
    <member name="M:Optimization.Objective.#ctor(Optimization.Expression,System.String,Optimization.ObjectiveSense)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Objective" /> class.
            </summary>
      <param name="expression">The expression.</param>
      <param name="name">The name.</param>
      <param name="sense">The sense.</param>
    </member>
    <member name="P:Optimization.Objective.Name">
      <summary>
            Unique name of this objective.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Objective.Sense">
      <summary>
            Sense of this objective.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Objective.Expression">
      <summary>
            Expression of this objective.
            </summary>
      <value />
    </member>
    <member name="M:Optimization.Operators.Interfaces.IOperator.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions using the specified variableValues
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Interfaces.IOperator.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.OperatorExpression">
      <invariant>_expressions!=null</invariant>
      <invariant>Expressions!=null</invariant>
      <invariant description="An Expression must not be null">_expressions.Count(x =&gt; (object)x == null) == 0</invariant>
    </member>
    <member name="M:Optimization.Operators.OperatorExpression.#ctor(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Expression" /> class.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="min">The minimal number of elements in expressions</param>
      <param name="max">The maximal number of elements in expressions</param>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="expressions != null" vb="expressions &lt;&gt; Nothing">expressions != null</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">expressions == null</exception>
      <requires description="You provided less than the neccessary number of operands" exception="T:System.ArgumentOutOfRangeException" csharp="Count&lt;Optimization.Expression&gt;(expressions) &gt;= min" vb="Count(expressions) &gt;= min">System.Linq.Enumerable.Count&lt;Optimization.Expression&gt;(expressions) &gt;= min</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">System.Linq.Enumerable.Count&lt;Optimization.Expression&gt;(expressions) &lt; min</exception>
      <requires description="You provided more than the allowed number of operands" exception="T:System.ArgumentOutOfRangeException" csharp="Count&lt;Optimization.Expression&gt;(expressions) &lt;= max" vb="Count(expressions) &lt;= max">System.Linq.Enumerable.Count&lt;Optimization.Expression&gt;(expressions) &lt;= max</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">System.Linq.Enumerable.Count&lt;Optimization.Expression&gt;(expressions) &gt; max</exception>
    </member>
    <member name="P:Optimization.Operators.OperatorExpression.Variables">
      <summary>
            Gets the variables.
            </summary>
    </member>
    <member name="P:Optimization.Operators.OperatorExpression.Terms">
      <summary>
            Gets the terms.
            </summary>
      <value>The terms.</value>
    </member>
    <member name="T:Optimization.Operators.Interfaces.IAbs">
      <summary>
            Describes the interface for the Abs operation
            </summary>
    </member>
    <member name="T:Optimization.Operators.Abs">
      <summary>
            Represents the Operator for an absolute value
            </summary>
    </member>
    <member name="M:Optimization.Operators.Abs.#ctor(Optimization.Expression,System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Abs" /> class.
            </summary>
      <param name="expression">An expression.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
    </member>
    <member name="M:Optimization.Operators.Abs.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Abs.BigM">
      <summary>
            A number which is used transforming the abs-expression into expressions, which can be handled by the solvers.
            It should be choosen large enough, so that the solution space is not cut. 
            But choosing this value too large, it can cause numerical errors.
            It's not used in cases, where only terms are used as operators, containing variables with finite bounds. 
            </summary>
    </member>
    <member name="P:Optimization.Operators.Abs.RepresentingVariable">
      <summary>
            A variable that can later be set to the representing variable when a model transformation for removing Abs- 
            expressions is applied.  
            </summary>
    </member>
    <member name="P:Optimization.Operators.Abs.isLinear">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with linear expressions. Linearity can be 
            re-established when modelling through linear constraints with new variables.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Operators.Abs.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms. Linearity can be
            re-established when modelling through linear constraints with new variables.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Interfaces.ICeil">
      <summary>
            Describes the interface for the Ceil operation
            </summary>
    </member>
    <member name="T:Optimization.Operators.Ceil">
      <summary>
            Represents the Operator for a ceil roundoff
            </summary>
    </member>
    <member name="M:Optimization.Operators.Ceil.#ctor(Optimization.Expression)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Ceil" /> class.
            </summary>
      <param name="expression">An expression.</param>
    </member>
    <member name="M:Optimization.Operators.Ceil.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Ceil.RepresentingVariable">
      <summary>
            A variable that can later be set to the representing variable when a model transformation for removing Ceil- 
            expressions is applied.  
            </summary>
    </member>
    <member name="P:Optimization.Operators.Ceil.isLinear">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with linear expressions. Linearity can be 
            re-established when modelling through linear constraints with a new variable.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Operators.Ceil.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms. Linearity can be 
            re-established when modelling through constraints with new variables.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Interfaces.IFloor">
      <summary>
            Describes the interface for the Floor operation
            </summary>
    </member>
    <member name="T:Optimization.Operators.Floor">
      <summary>
            Represents the Operator for a floor roundoff
            </summary>
    </member>
    <member name="M:Optimization.Operators.Floor.#ctor(Optimization.Expression)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Floor" /> class.
            </summary>
      <param name="expression">An expression.</param>
    </member>
    <member name="M:Optimization.Operators.Floor.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Floor.RepresentingVariable">
      <summary>
            A variable that can later be set to the representing variable when a model transformation for removing Floor- 
            expressions is applied.  
            </summary>
    </member>
    <member name="P:Optimization.Operators.Floor.isLinear">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with linear expressions. Linearity can be 
            re-established when modelling through linear constraints with a new variable.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Operators.Floor.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms. Linearity can be 
            re-established when modelling through constraints with new variables.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Interfaces.IMax">
      <summary>
            Describes the interface for the max operation
            </summary>
    </member>
    <member name="T:Optimization.Operators.Interfaces.IMin">
      <summary>
            Describes the interface for the min operation
            </summary>
    </member>
    <member name="T:Optimization.Operators.Interfaces.IPlus">
      <summary>
            Describes the interface for the plus operation
            </summary>
    </member>
    <member name="T:Optimization.Operators.Interfaces.ITimes">
      <summary>
            Describes the interface for the times operation
            </summary>
    </member>
    <member name="T:Optimization.Operators.Max">
      <summary>
            Represents the Operator for a maximum
            </summary>
    </member>
    <member name="M:Optimization.Operators.Max.#ctor(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Max" /> class.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <requires csharp="expressions != null" vb="expressions &lt;&gt; Nothing">expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Max.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Max.BigM">
      <summary>
            A number which is used transforming the max-expression into expressions, which can be handled by the solvers.
            It should be choosen large enough, so that the solution space is not cut. 
            But choosing this value too large, it can cause numerical errors.
            It's not used in cases, where only terms are used as operators, containing variables with finite bounds. 
            </summary>
    </member>
    <member name="P:Optimization.Operators.Max.RepresentingVariable">
      <summary>
            A variable that can later be set to the representing variable when a model transformation for removing Max- 
            expressions is applied.  
            </summary>
    </member>
    <member name="P:Optimization.Operators.Max.isLinear">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with linear expressions. Linearity can 
            be re-established when modelling through linear constraints with new variables, i.e., z=max(expression1,expression2) and w \in \{ 0,1\} 
            for two expressions 
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Operators.Max.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms. Linearity can be  
            re-established when modelling through linear constraints with new variables, i.e., z=max(expression1,expression2) and w \in \{ 0,1\}
            for two expresssions 
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Min">
      <summary>
            Represents the Operator for a minimum
            </summary>
    </member>
    <member name="M:Optimization.Operators.Min.#ctor(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Min" /> class. 
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <requires csharp="expressions != null" vb="expressions &lt;&gt; Nothing">expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Min.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Min.BigM">
      <summary>
            A number which is used transforming the min-expression into expressions, which can be handled by the solvers.
            It should be choosen large enough, so that the solution space is not cut. 
            But choosing this value too large, it can cause numerical errors.
            It's not used in cases, where only terms are used as operators, containing variables with finite bounds. 
            </summary>
    </member>
    <member name="P:Optimization.Operators.Min.RepresentingVariable">
      <summary>
            A variable that can later be set to the representing variable when a model transformation for removing Min- 
            expressions is applied.  
            </summary>
    </member>
    <member name="P:Optimization.Operators.Min.isLinear">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with linear expressions. Linearity can be re-established 
            when modelling through linear constraints with new variables, i.e., z=min(expression1,expression2) and w \in \{ 0,1\} 
            for two expressions.   
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Operators.Min.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms. Linearity can be 
            re-established when modelling through linear constraints with new variables, i.e., z=min(expression1,expression2) and w \in \{ 0,1\}
            for two expresssions 
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Plus">
      <summary>
            Represents the Operator for an addition
            </summary>
    </member>
    <member name="M:Optimization.Operators.Plus.#ctor(System.Collections.Generic.IEnumerable{Optimization.Expression})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Plus" /> class.
            </summary>
      <param name="expressions">The expressions.</param>
      <requires csharp="expressions != null" vb="expressions &lt;&gt; Nothing">expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Plus.#ctor(Optimization.Term,Optimization.Term)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Plus" /> class.
            </summary>
      <param name="term1">The first term.</param>
      <param name="term2">The second term.</param>
    </member>
    <member name="M:Optimization.Operators.Plus.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="M:Optimization.Operators.Plus.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Operators.Plus.op_Addition(Optimization.Operators.Plus,Optimization.Expression)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="plus">The plus.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="!Equals(plus, null)" vb="Not Equals(plus, Nothing)">!object.Equals(plus, null)</requires>
      <requires csharp="plus.Expressions != null" vb="plus.Expressions &lt;&gt; Nothing">plus.Expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Plus.op_Addition(Optimization.Expression,Optimization.Operators.Plus)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="expression">The expression.</param>
      <param name="plus">The plus.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(expression, null)" vb="Not Equals(expression, Nothing)">!object.Equals(expression, null)</requires>
      <requires csharp="!Equals(plus, null)" vb="Not Equals(plus, Nothing)">!object.Equals(plus, null)</requires>
      <requires csharp="plus.Expressions != null" vb="plus.Expressions &lt;&gt; Nothing">plus.Expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Plus.op_Addition(Optimization.Operators.Plus,Optimization.Term)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="plus">The plus.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="plus != null" vb="plus &lt;&gt; Nothing">plus != null</requires>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <requires csharp="plus.Expressions != null" vb="plus.Expressions &lt;&gt; Nothing">plus.Expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Plus.op_Addition(Optimization.Term,Optimization.Operators.Plus)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="term">The term.</param>
      <param name="plus">The plus.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(term, null)" vb="Not Equals(term, Nothing)">!object.Equals(term, null)</requires>
      <requires csharp="!Equals(plus, null)" vb="Not Equals(plus, Nothing)">!object.Equals(plus, null)</requires>
      <requires csharp="plus.Expressions != null" vb="plus.Expressions &lt;&gt; Nothing">plus.Expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Plus.op_Addition(Optimization.Operators.Plus,Optimization.Operators.Plus)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="plus1">The first plus.</param>
      <param name="plus2">The second plus.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(plus1, null)" vb="Not Equals(plus1, Nothing)">!object.Equals(plus1, null)</requires>
      <requires csharp="!Equals(plus2, null)" vb="Not Equals(plus2, Nothing)">!object.Equals(plus2, null)</requires>
      <requires csharp="plus1.Expressions != null" vb="plus1.Expressions &lt;&gt; Nothing">plus1.Expressions != null</requires>
      <requires csharp="plus2.Expressions != null" vb="plus2.Expressions &lt;&gt; Nothing">plus2.Expressions != null</requires>
    </member>
    <member name="P:Optimization.Operators.Plus.isLinear">
      <summary>
            Gets a value indicating whether this instance is linear.
            </summary>
      <value>
        <c>true</c> if this instance is linear; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Optimization.Operators.Plus.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Times">
      <summary>
            Represents the Operator for a multiplication
            </summary>
    </member>
    <member name="M:Optimization.Operators.Times.#ctor(System.Collections.Generic.IEnumerable{Optimization.Expression})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Times" /> class.
            </summary>
      <param name="expressions">The expressions.</param>
    </member>
    <member name="M:Optimization.Operators.Times.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Expression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="M:Optimization.Operators.Times.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Optimization.Operators.Times.isLinear">
      <summary>
            Gets or sets a value indicating whether this instance is linear.
            </summary>
      <value>
        <c>true</c> if this instance is linear; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Optimization.Operators.Times.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.ParameterCollection`1">
      <summary>
            A parameterCollection allows you to define parameters on Sets so that you can access parameter values with indices like in other modelling languages
            </summary>
      <typeparam name="T" />
    </member>
    <member name="M:Optimization.ParameterCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,System.Double},Optimization.Interfaces.ISetAccessor{`0,System.Object}[])">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.ParameterCollection`1" /> class.
            </summary>
      <param name="parameterValues">The parameter values.</param>
      <param name="valueExpression">The value expression.</param>
      <param name="sets">The sets.</param>
      <requires description="You need to provide a parameterValues collection." csharp="parameterValues != null" vb="parameterValues &lt;&gt; Nothing">parameterValues != null</requires>
    </member>
    <member name="P:Optimization.ParameterCollection`1.Item(System.Object[])">
      <summary>
            Gets the <see cref="T:System.Double" /> with the specified i.
            </summary>
      <value />
    </member>
    <member name="T:Optimization.GenericVariableCollectionBase">
      <summary>
             The base class vor all generic VariableCollection classes
            </summary>
    </member>
    <member name="M:Optimization.GenericVariableCollectionBase.SetVariableValues(System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
             Sets the value property for each variable in this VariableCollection to the corresponding value in the parameter 'values'. The matching happens by string comparison of the name of the variable.
            </summary>
      <param name="values">The values for the variables (e.g. coming from a solution)</param>
    </member>
    <member name="P:Optimization.GenericVariableCollectionBase.IndexValidation">
      <summary>
             Changes the behavior of a VariableCollection. If set to true the VariableCollection will validate if an index belongs to the sets the VariableCollection is based on
            </summary>
    </member>
    <member name="T:Optimization.VariableCollection`1">
      <summary>
            This is a strongly typed helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="M:Optimization.VariableCollection`1.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
    </member>
    <member name="M:Optimization.VariableCollection`1.#ctor(System.Func{`0,System.Text.StringBuilder},System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique name generator.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
    </member>
    <member name="M:Optimization.VariableCollection`1.#ctor(System.Func{`0,System.Text.StringBuilder},System.Func{`0,System.Double},System.Func{`0,System.Double},Optimization.VariableType,System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique name generator</param>
      <param name="lowerBoundGenerator">A lower bound generator</param>
      <param name="upperBoundGenerator">An upper bound generator</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
    </member>
    <member name="P:Optimization.VariableCollection`1.Item(`0)">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index1.
            </summary>
    </member>
    <member name="T:Optimization.VariableCollection`2">
      <summary>
            This is a strongly typed helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="M:Optimization.VariableCollection`2.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
    </member>
    <member name="M:Optimization.VariableCollection`2.#ctor(System.Func{`0,`1,System.Text.StringBuilder},System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique namegenerator.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
    </member>
    <member name="M:Optimization.VariableCollection`2.#ctor(System.Func{`0,`1,System.Text.StringBuilder},System.Func{`0,`1,System.Double},System.Func{`0,`1,System.Double},Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection`2" /> class.
            </summary>
      <param name="uniqueNamegenerator">The unique namegenerator.</param>
      <param name="lowerBoundGenerator">The lower bound generator.</param>
      <param name="upperBoundGenerator">The upper bound generator.</param>
      <param name="type">The type.</param>
      <param name="set1">The set1.</param>
      <param name="set2">The set2.</param>
    </member>
    <member name="P:Optimization.VariableCollection`2.Item(`0,`1)">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index.
            </summary>
    </member>
    <member name="T:Optimization.VariableCollection`3">
      <summary>
            This is a strongly typed helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="M:Optimization.VariableCollection`3.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
    </member>
    <member name="M:Optimization.VariableCollection`3.#ctor(System.Func{`0,`1,`2,System.Text.StringBuilder},System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique namegenerator.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
    </member>
    <member name="M:Optimization.VariableCollection`3.#ctor(System.Func{`0,`1,`2,System.Text.StringBuilder},System.Func{`0,`1,`2,System.Double},System.Func{`0,`1,`2,System.Double},Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection`3" /> class.
            </summary>
      <param name="uniqueNamegenerator">The unique namegenerator.</param>
      <param name="lowerBoundGenerator">The lower bound generator.</param>
      <param name="upperBoundGenerator">The upper bound generator.</param>
      <param name="type">The type.</param>
      <param name="set1">The set1.</param>
      <param name="set2">The set2.</param>
      <param name="set3">The set3.</param>
    </member>
    <member name="P:Optimization.VariableCollection`3.Item(`0,`1,`2)">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index.
            </summary>
    </member>
    <member name="T:Optimization.VariableCollection`4">
      <summary>
            This is a strongly typed helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="M:Optimization.VariableCollection`4.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
      <param name="set4">The fourth set</param>
    </member>
    <member name="M:Optimization.VariableCollection`4.#ctor(System.Func{`0,`1,`2,`3,System.Text.StringBuilder},System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique namegenerator.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
      <param name="set4">The fourth set</param>
    </member>
    <member name="M:Optimization.VariableCollection`4.#ctor(System.Func{`0,`1,`2,`3,System.Text.StringBuilder},System.Func{`0,`1,`2,`3,System.Double},System.Func{`0,`1,`2,`3,System.Double},Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection`4" /> class.
            </summary>
      <param name="uniqueNamegenerator">The unique namegenerator.</param>
      <param name="lowerBoundGenerator">The lower bound generator.</param>
      <param name="upperBoundGenerator">The upper bound generator.</param>
      <param name="type">The type.</param>
      <param name="set1">The set1.</param>
      <param name="set2">The set2.</param>
      <param name="set3">The set3.</param>
      <param name="set4">The set4.</param>
    </member>
    <member name="P:Optimization.VariableCollection`4.Item(`0,`1,`2,`3)">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index.
            </summary>
    </member>
    <member name="T:Optimization.VariableCollection`5">
      <summary>
            This is a strongly typed helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="M:Optimization.VariableCollection`5.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
      <param name="set4">The fourth set</param>
      <param name="set5">The fifth set</param>
    </member>
    <member name="M:Optimization.VariableCollection`5.#ctor(System.Func{`0,`1,`2,`3,`4,System.Text.StringBuilder},System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique namegenerator.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
      <param name="set4">The fourth set</param>
      <param name="set5">The fifth set</param>
    </member>
    <member name="M:Optimization.VariableCollection`5.#ctor(System.Func{`0,`1,`2,`3,`4,System.Text.StringBuilder},System.Func{`0,`1,`2,`3,`4,System.Double},System.Func{`0,`1,`2,`3,`4,System.Double},Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection`5" /> class.
            </summary>
      <param name="uniqueNamegenerator">The unique namegenerator.</param>
      <param name="lowerBoundGenerator">The lower bound generator.</param>
      <param name="upperBoundGenerator">The upper bound generator.</param>
      <param name="type">The type.</param>
      <param name="set1">The set1.</param>
      <param name="set2">The set2.</param>
      <param name="set3">The set3.</param>
      <param name="set4">The set4.</param>
      <param name="set5">The set5.</param>
    </member>
    <member name="P:Optimization.VariableCollection`5.Item(`0,`1,`2,`3,`4)">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index.
            </summary>
    </member>
    <member name="T:Optimization.VariableCollection`6">
      <summary>
            This is a strongly typed helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="M:Optimization.VariableCollection`6.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4},System.Collections.Generic.IEnumerable{`5})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
      <param name="set4">The fourth set</param>
      <param name="set5">The fifth set</param>
      <param name="set6">The sixth set</param>
    </member>
    <member name="M:Optimization.VariableCollection`6.#ctor(System.Func{`0,`1,`2,`3,`4,`5,System.Text.StringBuilder},System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4},System.Collections.Generic.IEnumerable{`5})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique namegenerator.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
      <param name="set4">The fourth set</param>
      <param name="set5">The fifth set</param>
      <param name="set6">The sixth set</param>
    </member>
    <member name="M:Optimization.VariableCollection`6.#ctor(System.Func{`0,`1,`2,`3,`4,`5,System.Text.StringBuilder},System.Func{`0,`1,`2,`3,`4,`5,System.Double},System.Func{`0,`1,`2,`3,`4,`5,System.Double},Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4},System.Collections.Generic.IEnumerable{`5})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection`6" /> class.
            </summary>
      <param name="uniqueNamegenerator">The unique namegenerator.</param>
      <param name="lowerBoundGenerator">The lower bound generator.</param>
      <param name="upperBoundGenerator">The upper bound generator.</param>
      <param name="type">The type.</param>
      <param name="set1">The set1.</param>
      <param name="set2">The set2.</param>
      <param name="set3">The set3.</param>
      <param name="set4">The set4.</param>
      <param name="set5">The set5.</param>
      <param name="set6">The set6.</param>
    </member>
    <member name="P:Optimization.VariableCollection`6.Item(`0,`1,`2,`3,`4,`5)">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index.
            </summary>
    </member>
    <member name="T:Optimization.VariableCollection`7">
      <summary>
            This is a strongly typed helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="M:Optimization.VariableCollection`7.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4},System.Collections.Generic.IEnumerable{`5},System.Collections.Generic.IEnumerable{`6})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
      <param name="set4">The fourth set</param>
      <param name="set5">The fifth set</param>
      <param name="set6">The sixth set</param>
      <param name="set7">The seventh set</param>
    </member>
    <member name="M:Optimization.VariableCollection`7.#ctor(System.Func{`0,`1,`2,`3,`4,`5,`6,System.Text.StringBuilder},System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4},System.Collections.Generic.IEnumerable{`5},System.Collections.Generic.IEnumerable{`6})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique namegenerator.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
      <param name="set4">The fourth set</param>
      <param name="set5">The fifth set</param>
      <param name="set6">The sixth set</param>
      <param name="set7">The seventh set</param>
    </member>
    <member name="M:Optimization.VariableCollection`7.#ctor(System.Func{`0,`1,`2,`3,`4,`5,`6,System.Text.StringBuilder},System.Func{`0,`1,`2,`3,`4,`5,`6,System.Double},System.Func{`0,`1,`2,`3,`4,`5,`6,System.Double},Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4},System.Collections.Generic.IEnumerable{`5},System.Collections.Generic.IEnumerable{`6})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection`7" /> class.
            </summary>
      <param name="uniqueNamegenerator">The unique namegenerator.</param>
      <param name="lowerBoundGenerator">The lower bound generator.</param>
      <param name="upperBoundGenerator">The upper bound generator.</param>
      <param name="type">The type.</param>
      <param name="set1">The set1.</param>
      <param name="set2">The set2.</param>
      <param name="set3">The set3.</param>
      <param name="set4">The set4.</param>
      <param name="set5">The set5.</param>
      <param name="set6">The set6.</param>
      <param name="set7">The set7.</param>
    </member>
    <member name="P:Optimization.VariableCollection`7.Item(`0,`1,`2,`3,`4,`5,`6)">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index.
            </summary>
    </member>
    <member name="T:Optimization.VariableCollection`8">
      <summary>
            This is a strongly typed helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="M:Optimization.VariableCollection`8.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4},System.Collections.Generic.IEnumerable{`5},System.Collections.Generic.IEnumerable{`6},System.Collections.Generic.IEnumerable{`7})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
      <param name="set4">The fourth set</param>
      <param name="set5">The fifth set</param>
      <param name="set6">The sixth set</param>
      <param name="set7">The seventh set</param>
            /// <param name="set8">The eighth set</param></member>
    <member name="M:Optimization.VariableCollection`8.#ctor(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,System.Text.StringBuilder},System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4},System.Collections.Generic.IEnumerable{`5},System.Collections.Generic.IEnumerable{`6},System.Collections.Generic.IEnumerable{`7})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique namegenerator.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="set1">The first set</param>
      <param name="set2">The second set</param>
      <param name="set3">The third set</param>
      <param name="set4">The fourth set</param>
      <param name="set5">The fifth set</param>
      <param name="set6">The sixth set</param>
      <param name="set7">The seventh set</param>
      <param name="set8">The eighth set</param>
    </member>
    <member name="M:Optimization.VariableCollection`8.#ctor(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,System.Text.StringBuilder},System.Func{`0,`1,`2,`3,`4,`5,`6,`7,System.Double},System.Func{`0,`1,`2,`3,`4,`5,`6,`7,System.Double},Optimization.VariableType,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4},System.Collections.Generic.IEnumerable{`5},System.Collections.Generic.IEnumerable{`6},System.Collections.Generic.IEnumerable{`7})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection`8" /> class.
            </summary>
      <param name="uniqueNamegenerator">The unique namegenerator.</param>
      <param name="lowerBoundGenerator">The lower bound generator.</param>
      <param name="upperBoundGenerator">The upper bound generator.</param>
      <param name="type">The type.</param>
      <param name="set1">The set1.</param>
      <param name="set2">The set2.</param>
      <param name="set3">The set3.</param>
      <param name="set4">The set4.</param>
      <param name="set5">The set5.</param>
      <param name="set6">The set6.</param>
      <param name="set7">The set7.</param>
      <param name="set8">The set8.</param>
    </member>
    <member name="P:Optimization.VariableCollection`8.Item(`0,`1,`2,`3,`4,`5,`6,`7)">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index.
            </summary>
    </member>
    <member name="T:Optimization.Solver.Interfaces.ICanWriteStatus">
      <summary>
            A solver class that implements this interface is able to provide status information about itself
            </summary>
    </member>
    <member name="P:Optimization.Solver.Interfaces.ICanWriteStatus.StatusInformation">
      <summary>
            Status information about a solver instance
            </summary>
    </member>
    <member name="P:Optimization.Solver.Interfaces.StatusInfo.SolverTime">
      <summary>
            The elapsed solver time in seconds
            </summary>
    </member>
    <member name="P:Optimization.Solver.Interfaces.StatusInfo.NodeCount">
      <summary>
            Current explored node count.
            </summary>
    </member>
    <member name="P:Optimization.Solver.Interfaces.StatusInfo.SolutionCount">
      <summary>
            Current count of feasible solutions found.
            </summary>
    </member>
    <member name="T:Optimization.Solver.Interfaces.StatusInformation">
      <summary>
            Statusinformation about a solver
            </summary>
    </member>
    <member name="T:Optimization.Solver.ModelStatus">
      <summary>
            Status of a solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelStatus.Unknown">
      <summary>
            Status of the solved model instance is unknown, e.g. because the solver has too little time to prove the model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelStatus.Unbounded">
      <summary>
            The solved model instance is unbounded.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelStatus.Infeasible">
      <summary>
            The solved model instance is infeasible.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelStatus.Feasible">
      <summary>
            The solved model instance is feasible.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelStatus.InfOrUnbd">
      <summary>
            The solved model instance is infeasible or unbounded.
            </summary>
    </member>
    <member name="T:Optimization.Solver.SolutionStatus">
      <summary>
            Status of a solution instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.NoSolutionValues">
      <summary>
            The solution instance contains no variable and objective values, e.g. because the solved model instance is infeasible.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.FeasibleContinuousRelaxation">
      <summary>
            The solution instance contains variable and objective values feasible for the continuous relaxation of the solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.OptimalContinuousRelaxation">
      <summary>
            The solution instance contains variable and objective values optimal for the continuous relaxation of the solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.Feasible">
      <summary>
            The solution instance contains variable and objective values feasible for the solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.ProbablyLocalOptimal">
      <summary>
            The solution instance contains variable and objective values probably local optimal for the solved model instance with the used <see cref="T:Optimization.Interfaces.ISolver" />.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.LocalOptimal">
      <summary>
            The solution instance contains variable and objective values local optimal for the solved model instance with the used <see cref="T:Optimization.Interfaces.ISolver" />.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.Optimal">
      <summary>
            The solution instance contains variable and objective values optimal for the solved model instance.
            </summary>
    </member>
    <member name="T:Optimization.SOSType">
      <summary>
            The SOS type
            </summary>
    </member>
    <member name="F:Optimization.SOSType.S1">
      <summary>
            A SOS1 is a set of variables in which at most one variable may be positive at an integer feasible solution.
            </summary>
    </member>
    <member name="F:Optimization.SOSType.S2">
      <summary>
            A SOS2 is a set of variables in which at most two variables may be positive at an integer feasible solution, and moreover, any positive variables must be adjacent in the ordering specified by the ordering values.
            </summary>
    </member>
    <member name="F:Optimization.SOSType.S3">
      <summary>
            The set of variables appearing in an equation with only binary variables and +1 or -1 coefficients, and a right-hand-side value of 1 - (number of -1 coefficients).  This is a special case of SOS1.
            </summary>
    </member>
    <member name="T:Optimization.Variable">
      <summary>
            Represents a variable in an <see cref="T:Optimization.Interfaces.IModel" />.
            </summary>
      <author>lbeckmann</author>
    </member>
    <member name="M:Optimization.Variable.#ctor(System.String,System.Double,System.Double,Optimization.VariableType)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Variable" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerbound">The lowerbound.</param>
      <param name="upperbound">The upperbound.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Optimization.Variable.op_Subtraction(Optimization.Variable,Optimization.Variable)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="variable">The first variable.</param>
      <param name="variable2">The second variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="variable2 != (Optimization.Variable)null" vb="variable2 &lt;&gt; ((Optimization.Variable)Nothing) ">variable2 != (Optimization.Variable)null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Subtraction(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Subtraction(System.Double,Optimization.Variable)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="constant">The constant.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Variable.op_Multiply(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Division(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator /.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>
            The result of the operator.
            </returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="constant != 0.0" vb="constant &lt;&gt; 0">constant != 0.0</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Multiply(Optimization.Variable,Optimization.Variable)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="variable1">The first variable.</param>
      <param name="variable2">The second variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="variable1 != (Optimization.Variable)null" vb="variable1 &lt;&gt; ((Optimization.Variable)Nothing) ">variable1 != (Optimization.Variable)null</requires>
      <requires csharp="variable2 != (Optimization.Variable)null" vb="variable2 &lt;&gt; ((Optimization.Variable)Nothing) ">variable2 != (Optimization.Variable)null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Multiply(System.Double,Optimization.Variable)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="constant">The constant.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Addition(Optimization.Variable,Optimization.Variable)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="variable">The first variable.</param>
      <param name="variable2">The second variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="variable2 != (Optimization.Variable)null" vb="variable2 &lt;&gt; ((Optimization.Variable)Nothing) ">variable2 != (Optimization.Variable)null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Addition(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Addition(System.Double,Optimization.Variable)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="constant">The constant.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.Equals(Optimization.Variable)">
      <summary>
            Compares this instance to the specified other.
            </summary>
      <param name="other">The other.</param>
      <returns />
    </member>
    <member name="M:Optimization.Variable.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Optimization.Variable.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
    </member>
    <member name="M:Optimization.Variable.op_LessThanOrEqual(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_GreaterThanOrEqual(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_LessThanOrEqual(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_GreaterThanOrEqual(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Equality(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Equality(Optimization.Variable,Optimization.Variable)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="var1">The first variable.</param>
      <param name="var2">The second variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="var1 != (Optimization.Variable)null" vb="var1 &lt;&gt; ((Optimization.Variable)Nothing) ">var1 != (Optimization.Variable)null</requires>
    </member>
    <member name="M:Optimization.Variable.op_Equality(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Inequality(Optimization.Variable,Optimization.Term)">
      <summary>
            Please use &lt;= and &gt;= to model !=
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Variable.op_Inequality(Optimization.Variable,System.Double)">
      <summary>
            Please use &lt;= and &gt;= to model !=
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Variable.op_UnaryNegation(Optimization.Variable)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="variable">The variable.</param>
      <returns>
            A term with the factor of -1 and the variable given.
            </returns>
    </member>
    <member name="M:Optimization.Variable.op_Inequality(Optimization.Variable,Optimization.Variable)">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="var1">The first variable.</param>
      <param name="var2">The second variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="var1 != (Optimization.Variable)null" vb="var1 &lt;&gt; ((Optimization.Variable)Nothing) ">var1 != (Optimization.Variable)null</requires>
    </member>
    <member name="P:Optimization.Variable.Name">
      <summary>
            Unique name of this variable.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Variable.LowerBound">
      <summary>
            Lower bound of this variable.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Variable.UpperBound">
      <summary>
            Upper bound of this variable.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Variable.Value">
      <summary>
            Gets or sets the value for this variable. This field can be used to assign solution values from a solver to the variables in the original model.
            </summary>
      <value>The value.</value>
    </member>
    <member name="P:Optimization.Variable.Type">
      <summary>
            Type of this variable.
            </summary>
      <value />
    </member>
    <member name="T:Optimization.Term">
      <summary>
            A term represents a variable and a coefficient which belongs to this variable (e.g. 2*x)
            </summary>
    </member>
    <member name="M:Optimization.Term.#ctor(Optimization.Interfaces.IVariable,System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Term" /> class.
            </summary>
      <param name="variable">The variable.</param>
      <param name="factor">The constant.</param>
      <exception cref="T:System.ArgumentNullException" />
    </member>
    <member name="M:Optimization.Term.op_Multiply(System.Double,Optimization.Term)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="factor">The factor.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!term.Equals(null)" vb="Not term.Equals(Nothing)">!term.Equals(null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Multiply(Optimization.Term,System.Double)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="term">The term.</param>
      <param name="factor">The factor.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(term, null)" vb="Not Equals(term, Nothing)">!object.Equals(term, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Subtraction(System.Double,Optimization.Term)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="constant">The constant.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Subtraction(Optimization.Term,System.Double)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="term">The term.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Addition(System.Double,Optimization.Term)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="constant">The constant.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Addition(Optimization.Term,System.Double)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="term">The term.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Multiply(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Multiply(Optimization.Term,Optimization.Variable)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="term">The term.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Subtraction(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Subtraction(Optimization.Term,Optimization.Variable)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="term">The term.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Addition(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Addition(Optimization.Term,Optimization.Variable)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="term">The term.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!variable.Equals((Optimization.Variable)null)" vb="Not variable.Equals(((Optimization.Variable)Nothing))">!variable.Equals((Optimization.Variable)null)</requires>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Addition(Optimization.Term,Optimization.Term)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="term">The first term.</param>
      <param name="term2">The second term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <requires csharp="term2 != null" vb="term2 &lt;&gt; Nothing">term2 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Subtraction(Optimization.Term,Optimization.Term)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="term">The term.</param>
      <param name="term2">The term2.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <requires csharp="term2 != null" vb="term2 &lt;&gt; Nothing">term2 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Multiply(Optimization.Term,Optimization.Term)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="term">The term.</param>
      <param name="term2">The term2.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
      <requires csharp="term2 != null" vb="term2 &lt;&gt; Nothing">term2 != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_UnaryNegation(Optimization.Term)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires csharp="!Equals(term, null)" vb="Not Equals(term, Nothing)">!object.Equals(term, null)</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Implicit(Optimization.Variable)~Optimization.Term">
      <summary>
            Performs an implicit conversion from <see cref="T:Optimization.Variable" /> to <see cref="T:Optimization.Term" />.
            </summary>
      <param name="variable">The variable.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="P:Optimization.Term.Factor">
      <summary>
            Gets the factor.
            </summary>
    </member>
    <member name="P:Optimization.Term.Variable">
      <summary>
            Gets the variable.
            </summary>
    </member>
    <member name="P:Optimization.Term.isLinear">
      <summary>
            Gets or sets a value indicating whether this instance is linear.
            </summary>
      <value>
        <c>true</c> if this instance is linear; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Term.Variables">
      <summary>
            Gets the variables.
            </summary>
    </member>
    <member name="P:Optimization.Term.Terms">
      <summary>
            Gets the terms.
            </summary>
    </member>
    <member name="T:Optimization.UnitVariableCollection">
      <summary>
            This is essentially a helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="T:Optimization.UnitVariableCollection.UniqueNameGenerator">
      <summary>
            A delegate which takes an array of objects (making up the index) and returns a stringbuilder which holds a unique id for this index
            </summary>
      <param name="index">The index.</param>
      <returns>a unique id for this index</returns>
    </member>
    <member name="T:Optimization.UnitVariableCollection.BoundGenerator">
      <summary>
            A delegate which takes an array of objects (making up the index) and returns a bound to be used for a variable
            </summary>
      <param name="index">The index.</param>
      <returns />
    </member>
    <member name="M:Optimization.UnitVariableCollection.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,Optimization.ComplexUnit,System.Collections.IEnumerable[])">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.UnitVariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="sets">The sets.</param>
    </member>
    <member name="M:Optimization.UnitVariableCollection.#ctor(Optimization.UnitVariableCollection.UniqueNameGenerator,Optimization.UnitVariableCollection.BoundGenerator,Optimization.UnitVariableCollection.BoundGenerator,Optimization.VariableType,Optimization.ComplexUnit,System.Collections.IEnumerable[])">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.UnitVariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique namegenerator.</param>
      <param name="upperBoundGenerator">A generator function for the upper bound</param>
      <param name="type">The type.</param>
      <param name="sets">The sets.</param>
      <param name="lowerBoundGenerator">A generator function for the lower bound</param>
    </member>
    <member name="M:Optimization.UnitVariableCollection.#ctor(Optimization.UnitVariableCollection.UniqueNameGenerator,System.Double,System.Double,Optimization.VariableType,Optimization.ComplexUnit,System.Collections.IEnumerable[])">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.UnitVariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">The unique namegenerator.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="sets">The sets.</param>
    </member>
    <member name="M:Optimization.UnitVariableCollection.SetVariableValues(System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
             Sets the value property for each variable in this VariableCollection to the corresponding value in the parameter 'values'. The matching happens by string comparison of the name of the variable.
            </summary>
      <param name="values">The values for the variables (e.g. coming from a solution)</param>
    </member>
    <member name="M:Optimization.UnitVariableCollection.CreateAllVariables">
      <summary>
            Creates all variables that can possibly be created based on the elements currently in the sets.
            </summary>
      <returns>All variables in this VariableCollection</returns>
    </member>
    <member name="P:Optimization.UnitVariableCollection.IndexValidation">
      <summary>
             Changes the behavior of a VariableCollection. If set to true the VariableCollection will validate if an index belongs to the sets the VariableCollection is based on
            </summary>
    </member>
    <member name="P:Optimization.UnitVariableCollection.Item(System.Object[])">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index.
            </summary>
      <value />
    </member>
    <member name="T:Optimization.VariableType">
      <summary>
            Type of a <see cref="T:Optimization.Interfaces.IVariable" />.
            </summary>
    </member>
    <member name="F:Optimization.VariableType.Integer">
      <summary>
            Whole number.
            </summary>
    </member>
    <member name="F:Optimization.VariableType.Continuous">
      <summary>
            Continuous number.
            </summary>
    </member>
    <member name="T:Optimization.SetAccessor`2">
      <summary>
            Defines a Set and an Accessor function
            </summary>
      <typeparam name="T">The type of the Set</typeparam>
      <typeparam name="S">The return type of the Accessor function</typeparam>
    </member>
    <member name="M:Optimization.SetAccessor`2.#ctor(System.Collections.Generic.IEnumerable{`1},System.Func{`0,`1})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.SetAccessor`2" /> class.
            </summary>
      <param name="set">The set.</param>
      <param name="accessor">The accessor.</param>
    </member>
    <member name="P:Optimization.SetAccessor`2.Set">
      <summary>
            Gets the set.
            </summary>
      <value>The set.</value>
    </member>
    <member name="P:Optimization.SetAccessor`2.Accessor">
      <summary>
            Gets the accessor.
            </summary>
      <value>The accessor.</value>
    </member>
    <member name="T:Optimization.Solution">
      <summary>
            Represents a solution of an <see cref="T:Optimization.Model" />.
            </summary>
      <author>fseidel, skramkowski</author>
    </member>
    <member name="F:Optimization.Solution._modelName">
      <summary>
            Name of the solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solution._modelStatus">
      <summary>
            Status of the solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solution._overallWallTime">
      <summary>
            Overall wall clock time taken for solving.
            </summary>
    </member>
    <member name="M:Optimization.Solution.#ctor(System.String,System.TimeSpan,Optimization.Solver.ModelStatus,Optimization.Solver.SolutionStatus,System.Collections.Generic.IDictionary{System.String,System.Double},System.Collections.Generic.IDictionary{System.String,System.Double},System.Collections.Generic.IDictionary{System.String,System.Double},Optimization.ConflictingSet,System.Int64)">
      <summary>
            Creates a new solution instance.
            </summary>
      <param name="modelName">Name of the solved model instance.</param>
      <param name="overallWallTime">Overall wall clock time taken for solving.</param>
      <param name="modelStatus">Status of the solved model instance.</param>
      <param name="status">Status of the new solution instance.</param>
      <param name="variableValues">Name and solution value for each variable in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.</param>
      <param name="dualVariableValues">Name and solution value for each dual variable in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.</param>
      <param name="objectiveValues">Name and solution value for each objective in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.</param>
      <param name="numberOfExploredNodes">The number of explored nodes</param>
    </member>
    <member name="M:Optimization.Solution.CompareTo(Optimization.Solution)">
      <summary>
            Compares the objective values of this solution instance to <paramref name="other" />s.
            </summary>
      <param name="other">Solution instance to compare to.</param>
      <returns>If the objective values are compared, the return value indicates dominance of solution quality (i.e. zero indicates indifference).</returns>
      <exception cref="T:System.NotSupportedException">If this solution instance has status <c>NoSolutionValues</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="other" /> has status <c>NoSolutionValues</c> or the solutions' objective names do not fit to each other.</exception>
    </member>
    <member name="M:Optimization.Solution.Equals(System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Indicates whether the variable values of this solution instance are equal to <paramref name="otherVariableValues" />.
            </summary>
      <param name="otherVariableValues">The variable values to compare to.</param>
      <returns />
      <exception cref="T:System.NotSupportedException">If this solution instance has status <c>NoSolutionValues</c>.</exception>
      <exception cref="T:System.ArgumentException">If the solutions' variable names do not fit to each other.</exception>
    </member>
    <member name="M:Optimization.Solution.Equals(Optimization.Solution)">
      <summary>
            Indicates whether the objective values of this solution instance are equal to <paramref name="other" />s.
            </summary>
      <param name="other">The <see cref="T:Optimization.Solution" /> to compare to.</param>
      <returns />
      <exception cref="T:System.InvalidOperationException">If this solution instance has status <c>NoSolutionValues</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="other" /> has status <c>NoSolutionValues</c> or the solutions' objective names do not fit to each other.</exception>
    </member>
    <member name="M:Optimization.Solution.ClearValues">
      <summary>
            Removes the variable values and objective values from this solution instance and sets the status to <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="M:Optimization.Solution.GetVariableValue(System.String)">
      <summary>
            Returns the solution value of the variable named <paramref name="name" />, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
      <param name="name">Name of the variable.</param>
      <returns />
    </member>
    <member name="M:Optimization.Solution.GetObjectiveValue(System.String)">
      <summary>
            Returns the solution value of the objective named <paramref name="name" />, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
      <param name="name">Name of the objective.</param>
      <returns />
    </member>
    <member name="P:Optimization.Solution.ConflictingSet">
      <summary>
            Gets the conflicting set.
            </summary>
    </member>
    <member name="P:Optimization.Solution.Status">
      <summary>
            Status of this solution instance.
            </summary>
    </member>
    <member name="P:Optimization.Solution.ModelName">
      <summary>
            Gets the name of the model.
            </summary>
      <value>The name of the model.</value>
    </member>
    <member name="P:Optimization.Solution.ModelStatus">
      <summary>
            Gets the model status.
            </summary>
      <value>The model status.</value>
    </member>
    <member name="P:Optimization.Solution.OverallWallTime">
      <summary>
            Gets the overall wall time.
            </summary>
      <value>The overall wall time.</value>
    </member>
    <member name="P:Optimization.Solution.BestBound">
      <summary>
             Returns the best bound
            </summary>
    </member>
    <member name="P:Optimization.Solution.Gap">
      <summary>
             Gets the solution gap
            </summary>
    </member>
    <member name="P:Optimization.Solution.VariableValues">
      <summary>
            Unique name and solution value for each variable in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="P:Optimization.Solution.DualVariableValues">
      <summary>
            Unique name and solution value for each dual variable in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="P:Optimization.Solution.ObjectiveValues">
      <summary>
            Unique name and solution value for each objective in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="T:Optimization.SolverConfiguration">
      <summary>
            Defines common parameters for <see cref="T:Optimization.Interfaces.ISolver" /> instances.
            </summary>
      <author>skramkowski</author>
    </member>
    <member name="P:Optimization.SolverConfiguration.CalculateDuals">
      <summary>
            Gets or sets a value indicating whether duals shall be calculated or not.
            </summary>
      <value>
        <c>true</c> if duals should be calculated; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Optimization.SolverConfiguration.TimeLimit">
      <summary>
            Limits the total time expended (in seconds). Time measurement could differ in different solvers.
            </summary>
      <value>
            The time limit.
            </value>
      <setter>
        <requires csharp="value &gt;= 0.0" vb="value &gt;= 0">value &gt;= 0.0</requires>
      </setter>
    </member>
    <member name="P:Optimization.SolverConfiguration.OptimalityTolerance">
      <summary>
            Dual feasibility tolerance. Reduced costs must all be smaller than OptimalityTol in the improving direction in order for a model to be declared optimal.
            </summary>
      <value>
            The optimality tolerance.
            </value>
      <setter>
        <requires csharp="value &gt;= 0.0" vb="value &gt;= 0">value &gt;= 0.0</requires>
      </setter>
    </member>
    <member name="P:Optimization.SolverConfiguration.MIPGap">
      <summary>
            Relative MIP optimality gap (MIP only). The MIP solver will terminate (with an optimal result) when the relative gap between the lower and upper objective bound is less than MIPGap times the upper bound.
            </summary>
      <value>
            Sets a relative tolerance on the gap between the best integer objective and the objective of the best node remaining. When the value
            |bestnode-bestinteger|/(1e-10+|bestinteger|)
            falls below the value of this parameter, the mixed integer optimization is stopped.
            For example, to instruct CPLEX to stop as soon as it has found a feasible integer solution proved to be within five percent of optimal, set the relative mipgap tolerance to 0.05.
            </value>
      <setter>
        <requires csharp="value &gt;= 0.0" vb="value &gt;= 0">value &gt;= 0.0</requires>
      </setter>
    </member>
    <member name="P:Optimization.SolverConfiguration.MIPGapAbs">
      <summary>
            Absolute MIP optimality gap (MIP only). The MIP solver will terminate (with an optimal result) when the absolute gap between the lower and upper objective bound is less than MIPGapAbs.
            </summary>
      <value>
            The MIP gap abs.
            </value>
      <setter>
        <requires csharp="value &gt;= 0.0" vb="value &gt;= 0">value &gt;= 0.0</requires>
      </setter>
    </member>
    <member name="T:Optimization.SumExpressionBuilder">
      <summary>
            This is a helper class to support efficiently building Expressions from a collection of Terms
            </summary>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.SumExpressionBuilder" /> class.
            </summary>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.Clear">
      <summary>
            Clears this instance.
            </summary>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.Add(Optimization.Term)">
      <summary>
            Adds the specified term.
            </summary>
      <param name="term">The term.</param>
      <requires csharp="term != null" vb="term &lt;&gt; Nothing">term != null</requires>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.ToExpression">
      <summary>
            Converts a list of terms to an expression by summing them up
            </summary>
      <returns>the resulting Expression</returns>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.Add(Optimization.Expression)">
      <summary>
            Adds the specified expression.
            </summary>
      <param name="expression">The expression.</param>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.Add(Optimization.Variable)">
      <summary>
            Adds the specified variable.
            </summary>
      <param name="variable">The variable.</param>
      <requires csharp="variable != null" vb="variable &lt;&gt; Nothing">variable != null</requires>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.Add(System.Double)">
      <summary>
            Adds the specified constant.
            </summary>
      <param name="constant">The constant.</param>
    </member>
    <member name="M:Optimization.SimpleUnit.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.ComplexUnit.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Optimization.VariableCollection">
      <summary>
            This is essentially a helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="T:Optimization.VariableCollection.UniqueNameGenerator">
      <summary>
            A delegate which takes an array of objects (making up the index) and returns a stringbuilder which holds a unique id for this index
            </summary>
      <param name="index">The index.</param>
      <returns>a unique id for this index</returns>
    </member>
    <member name="T:Optimization.VariableCollection.BoundGenerator">
      <summary>
            A delegate which takes an array of objects (making up the index) and returns a bound to be used for a variable
            </summary>
      <param name="index">The index.</param>
      <returns />
    </member>
    <member name="M:Optimization.VariableCollection.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.IEnumerable[])">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="sets">The sets.</param>
    </member>
    <member name="M:Optimization.VariableCollection.#ctor(Optimization.VariableCollection.UniqueNameGenerator,Optimization.VariableCollection.BoundGenerator,Optimization.VariableCollection.BoundGenerator,Optimization.VariableType,System.Collections.IEnumerable[])">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">A unique namegenerator.</param>
      <param name="upperBoundGenerator">A generator function for the upper bound</param>
      <param name="type">The type.</param>
      <param name="sets">The sets.</param>
      <param name="lowerBoundGenerator">A generator function for the lower bound</param>
    </member>
    <member name="M:Optimization.VariableCollection.#ctor(Optimization.VariableCollection.UniqueNameGenerator,System.Double,System.Double,Optimization.VariableType,System.Collections.IEnumerable[])">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="uniqueNamegenerator">The unique namegenerator.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="sets">The sets.</param>
    </member>
    <member name="M:Optimization.VariableCollection.SetVariableValues(System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
             Sets the value property for each variable in this VariableCollection to the corresponding value in the parameter 'values'. The matching happens by string comparison of the name of the variable.
            </summary>
      <param name="values">The values for the variables (e.g. coming from a solution)</param>
    </member>
    <member name="M:Optimization.VariableCollection.CreateAllVariables">
      <summary>
            Creates all variables that can possibly be created based on the elements currently in the sets.
            </summary>
      <returns>All variables in this VariableCollection</returns>
    </member>
    <member name="P:Optimization.VariableCollection.IndexValidation">
      <summary>
             Changes the behavior of a VariableCollection. If set to true the VariableCollection will validate if an index belongs to the sets the VariableCollection is based on
            </summary>
    </member>
    <member name="P:Optimization.VariableCollection.Item(System.Object[])">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index.
            </summary>
      <value />
    </member>
    <member name="T:Common.ExtensionMethods">
      <summary>
            Holds all Extension methods that are used throughout the framework
            </summary>
    </member>
    <member name="M:Common.ExtensionMethods.IsInteger(System.Double)">
      <summary>
            Determines whether the specified value is an integer value
            </summary>
      <param name="value">The value.</param>
      <returns>
        <c>true</c> if the specified value is long; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Common.ExtensionMethods.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Executes action on every element of source
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">The source.</param>
      <param name="action">The action.</param>
    </member>
    <member name="M:Common.ExtensionMethods.MultiplyElements(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Multiplies the elements and returns the result.
            </summary>
      <param name="source">The source.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Common.ExtensionMethods.CartesianProduct``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Cartesians the product.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sequences">The sequences.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Common.ICloneable`1">
      <summary>
            Supports cloning, which creates a new instance of the same type with the same value as an existing instance.
            </summary>
      <typeparam name="T">The type of the original instance.</typeparam>
      <author>skramkowski</author>
    </member>
    <member name="M:Common.ICloneable`1.Clone">
      <summary>
            Creates a new object of type <typeparamref name="T" /> that is a copy of the current instance.
            </summary>
      <returns>A new object of type <typeparamref name="T" /> that is a copy of this instance.</returns>
      <remarks>Clone can be implemented either as a deep copy or a shallow copy. In a deep copy, all objects are duplicated; whereas, in a shallow copy, only the top-level objects are duplicated and the lower levels contain references.</remarks>
    </member>
    <member name="T:Common.ArrayEqualityComparer">
      <summary>
             This EqualityComparer can compare if an array of objects is equal to another array of objects by comparing the contained objects itself
            </summary>
    </member>
    <member name="M:Common.ArrayEqualityComparer.Equals(System.Object[],System.Object[])">
      <summary>
            Determines whether the specified objects are equal.
            </summary>
      <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
      <param name="x">The first object of type <paramref name="T" /> to compare.</param>
      <param name="y">The second object of type <paramref name="T" /> to compare.</param>
    </member>
    <member name="M:Common.ArrayEqualityComparer.GetHashCode(System.Object[])">
      <summary>
            Returns a hash code for the specified object.
            </summary>
      <returns>
            A hash code for the specified object.
            </returns>
      <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
      <exception cref="T:System.ArgumentNullException">The type of <paramref name="obj" /> is a reference type and <paramref name="obj" /> is null.</exception>
    </member>
    <member name="T:Optimization.Configuration.OptimizationConfigSection">
      <summary>
            The OptimizationConfigSection Configuration Section.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.OptimizationConfigSection.OptimizationConfigSectionSectionName">
      <summary>
            The XML name of the OptimizationConfigSection Configuration Section.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.OptimizationConfigSection.XmlnsPropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.OptimizationConfigSection.Xmlns" /> property.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.OptimizationConfigSection.ModelElementPropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.OptimizationConfigSection.ModelElement" /> property.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.OptimizationConfigSection.SolverItemsPropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.OptimizationConfigSection.SolverItems" /> property.
            </summary>
    </member>
    <member name="M:Optimization.Configuration.OptimizationConfigSection.IsReadOnly">
      <summary>
            Gets a value indicating whether the element is read-only.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.OptimizationConfigSection.Instance">
      <summary>
            Gets the OptimizationConfigSection instance.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.OptimizationConfigSection.Xmlns">
      <summary>
            Gets the XML namespace of this Configuration Section.
            </summary>
      <remarks>
            This property makes sure that if the configuration file contains the XML namespace,
            the parser doesn't throw an exception because it encounters the unknown "xmlns" attribute.
            </remarks>
    </member>
    <member name="P:Optimization.Configuration.OptimizationConfigSection.ModelElement">
      <summary>
            Gets or sets defines settings for all models you will create within this application.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.OptimizationConfigSection.SolverItems">
      <summary>
            Gets or sets the solvers collection allows you to specify settings for solvers you want to use within this application.
            </summary>
    </member>
    <member name="T:Optimization.Configuration.ModelElement">
      <summary>
            Defines settings for all models you will create in within this application.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.ModelElement.BehaviorPropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.ModelElement.Behavior" /> property.
            </summary>
    </member>
    <member name="M:Optimization.Configuration.ModelElement.IsReadOnly">
      <summary>
            Gets a value indicating whether the element is read-only.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.ModelElement.Behavior">
      <summary>
            Gets or sets 'auto' will turn on automatic variable handling, i.e. when you add constraints and objectives the variables in them will be added automatically (default), 'manual' will turn this feature off and you need to add variables manually to the model
            </summary>
    </member>
    <member name="T:Optimization.Configuration.SolversCollection">
      <summary>
            The solvers collection allows you to specify settings for solvers you want to use within this application.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.SolversCollection.SolverElementPropertyName">
      <summary>
            The XML name of the individual <see cref="T:Optimization.Configuration.SolverElement" /> instances in this collection.
            </summary>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.IsElementName(System.String)">
      <summary>
            Indicates whether the specified <see cref="T:System.Configuration.ConfigurationElement" /> exists in the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
            </summary>
      <param name="elementName">The name of the element to verify.</param>
      <returns>
        <see langword="true" /> if the element exists in the collection; otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
            Gets the element key for the specified configuration element.
            </summary>
      <param name="element">The <see cref="T:System.Configuration.ConfigurationElement" /> to return the key for.</param>
      <returns>
            An <see cref="T:System.Object" /> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement" />.
            </returns>
      <requires inheritedFrom="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" inheritedFromTypeName="ConfigurationElementCollection" csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <ensures inheritedFrom="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" inheritedFromTypeName="ConfigurationElementCollection" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.CreateNewElement">
      <summary>
            Creates a new <see cref="T:Optimization.Configuration.SolverElement" />.
            </summary>
      <returns>
            A new <see cref="T:Optimization.Configuration.SolverElement" />.
            </returns>
      <ensures inheritedFrom="M:System.Configuration.ConfigurationElementCollection.CreateNewElement" inheritedFromTypeName="ConfigurationElementCollection" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.Add(Optimization.Configuration.SolverElement)">
      <summary>
            Adds the specified <see cref="T:Optimization.Configuration.SolverElement" /> to the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
            </summary>
      <param name="solver">The <see cref="T:Optimization.Configuration.SolverElement" /> to add.</param>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.Remove(Optimization.Configuration.SolverElement)">
      <summary>
            Removes the specified <see cref="T:Optimization.Configuration.SolverElement" /> from the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
            </summary>
      <param name="solver">The <see cref="T:Optimization.Configuration.SolverElement" /> to remove.</param>
      <requires csharp="solver != null" vb="solver &lt;&gt; Nothing">solver != null</requires>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.GetItemAt(System.Int32)">
      <summary>
            Gets the <see cref="T:Optimization.Configuration.SolverElement" /> at the specified index.
            </summary>
      <param name="index">The index of the <see cref="T:Optimization.Configuration.SolverElement" /> to retrieve.</param>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.GetItemByKey(System.String)">
      <summary>
            Gets the <see cref="T:Optimization.Configuration.SolverElement" /> with the specified key.
            </summary>
      <param name="name">The key of the <see cref="T:Optimization.Configuration.SolverElement" /> to retrieve.</param>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether the element is read-only.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.SolversCollection.CollectionType">
      <summary>
            Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
            </summary>
      <returns>The <see cref="T:System.Configuration.ConfigurationElementCollectionType" /> of this collection.</returns>
    </member>
    <member name="P:Optimization.Configuration.SolversCollection.ElementName">
      <summary>
            Gets the name used to identify this collection of elements
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Configuration.ConfigurationElementCollection.get_ElementName" inheritedFromTypeName="ConfigurationElementCollection" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Optimization.Configuration.SolversCollection.Item(System.Int32)">
      <summary>
            Gets the <see cref="T:Optimization.Configuration.SolverElement" /> at the specified index.
            </summary>
      <param name="index">The index of the <see cref="T:Optimization.Configuration.SolverElement" /> to retrieve.</param>
    </member>
    <member name="P:Optimization.Configuration.SolversCollection.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Optimization.Configuration.SolverElement" /> with the specified key.
            </summary>
      <param name="name">The key of the <see cref="T:Optimization.Configuration.SolverElement" /> to retrieve.</param>
    </member>
    <member name="T:Optimization.Configuration.SolverElement">
      <summary>
            Specifies settings for a particular solver.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.SolverElement.NamePropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.SolverElement.Name" /> property.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.SolverElement.PathPropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.SolverElement.Path" /> property.
            </summary>
    </member>
    <member name="M:Optimization.Configuration.SolverElement.IsReadOnly">
      <summary>
            Gets a value indicating whether the element is read-only.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.SolverElement.Name">
      <summary>
            Gets or sets the name of a specific solver ("Cplex" is the default)
            </summary>
    </member>
    <member name="P:Optimization.Configuration.SolverElement.Path">
      <summary>
            Gets or sets specifies the path to the native dll of this solver.  You can also use relative paths, like "..\..\cplex.dll"
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex124.BranchCallback.Main">
      <summary>
            Cplex callback, which is called when Cplex is in branching mode.
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex124.BranchCallback.GetBranches">
      <summary>
            Gets the path to the current node, on which Cplex branches.
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex124.BranchCallback.GetPreviousBranches">
      <summary>
            Gets the previous branches for the current node.
            </summary>
    </member>
    <member name="T:Optimization.Solver.Cplex124.ICanSetCutOff">
      <summary>
            A solver implementing this interface is able to set a cut off value
            </summary>
    </member>
    <member name="P:Optimization.Solver.Cplex124.ICanSetCutOff.SetCutOff">
      <summary>
            Gets or sets the set cut off.
            </summary>
      <value>
            The set cut off.
            </value>
    </member>
    <member name="T:Optimization.Solver.Cplex124.CplexSolver">
      <summary>
            Represents a CPLEX solver instance for mathematical programming problems.
            </summary>
      <author>larsbeck, floriani</author>
    </member>
    <member name="M:Optimization.Solver.Cplex124.CplexSolver.#ctor(Optimization.SolverConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.Cplex124.CplexSolver" /> class.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="M:Optimization.Solver.Cplex124.CplexSolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.Cplex124.CplexSolver" /> class.
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex124.CplexSolver.Abort">
      <summary>
            If this solver instance is busy abort the run as soon as possible, or do nothing if this solver instance is not busy.
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex124.CplexSolver.ClearLastModel">
      <summary>
            Deletes the internal datastructures of this solver instance.
            </summary>
      <exception cref="T:System.InvalidOperationException">If this solver instance is busy.</exception>
    </member>
    <member name="M:Optimization.Solver.Cplex124.CplexSolver.Solve(Optimization.Model,System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Solves the given <paramref name="model" />.
            Optimizes if <paramref name="model" /> contains at least one objective.
            </summary>
      <param name="model">The model to solve.</param>
      <param name="variableValues">Initial values for all or a subset of variables in <paramref name="model" />.</param>
      <returns>
      </returns>
      <exception cref="T:System.NotSupportedException">If this solver instance not supports solving.</exception>
      <exception cref="T:System.InvalidOperationException">If this solver instance is busy.</exception>
      <exception cref="T:System.ArgumentException">If this solver instance cannot handle the kind of <paramref name="model" />.</exception>
    </member>
    <member name="M:Optimization.Solver.Cplex124.CplexSolver.GetPresolvedModel(Optimization.Model)">
      <summary>
            Returns a presolve version of the given model
            </summary>
      <param name="model">The given model</param>
      <returns>Returns the presolved model, or null if an error occurs</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex124.CplexSolver.OnBranched(Optimization.Solver.Cplex.CplexBranchingEventArgs)">
      <summary>
            Raises the <see cref="E:Optimization.Solver.Cplex124.CplexSolver.Branched" /> event.
            </summary>
      <param name="e">The <see cref="T:Optimization.Solver.Cplex.CplexBranchingEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="P:Optimization.Solver.Cplex124.CplexSolver.Output">
      <summary>
            Gets or sets the output textwriter. By setting this property you are able to redirect the solver's output.
            </summary>
      <value>
            The output.
            </value>
    </member>
    <member name="P:Optimization.Solver.Cplex124.CplexSolver.OutputFile">
      <summary>
            Gets or sets the output file name. Based on the file extension an .lp file or .mps file will be written.
            </summary>
      <value>
            The output file.
            </value>
    </member>
    <member name="P:Optimization.Solver.Cplex124.CplexSolver.Configuration">
      <summary>
            The configuration of this solver instance.
            </summary>
    </member>
    <member name="P:Optimization.Solver.Cplex124.CplexSolver.IsBusy">
      <summary>
            Is this solver instance busy?
            </summary>
    </member>
    <member name="E:Optimization.Solver.Cplex124.CplexSolver.Branched">
      <summary>
            Occurs when Cplex branches on a node.
            </summary>
    </member>
    <member name="T:Optimization.Solver.Cplex124.CplexSolverConfiguration">
      <summary>
            Configuration for a Cplex solver instance
            </summary>
    </member>
    <member name="T:Optimization.Solver.Cplex124.NumExprVisitor">
      <summary>
            This is a helper class to create an expression for the CPLEXSolver visiting all nodes of an Optimization.Model.Expression
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex124.NumExprVisitor.#ctor(System.Collections.Generic.Dictionary{System.String,ILOG.Concert.INumVar},ILOG.CPLEX.Cplex)">
      <summary>
            Initializes a new instance of of the <see cref="T:Optimization.Solver.Cplex124.NumExprVisitor" /> class.
            Constructor used for creating an expression-visitor for CPLEX.
            </summary>
      <param name="variables">All variables of a model in CPLEX</param>
      <param name="cplex">The corresponding model in CPLEX</param>
    </member>
    <member name="M:Optimization.Solver.Cplex124.NumExprVisitor.VisitTerm(Optimization.Term)">
      <summary>
            Returns a new expression for CPLEX representing a Term
            </summary>
      <param name="Term">An Optimization.Model.Expression as Term</param>
      <returns>The expression representing a Term</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex124.NumExprVisitor.VisitConstant(Optimization.ConstantExpression)">
      <summary>
            Returns a new expression for CPLEX representing a constant
            </summary>
      <param name="ConstantExpression">An Optimization.Model.Expression as ConstantExpression</param>
      <returns>The expression representing a constant</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex124.NumExprVisitor.VisitTimes(Optimization.Operators.Interfaces.ITimes)">
      <summary>
            Returns an expression for CPLEX created as product of a factor and an expresions(INumExpr) or as quadratic expression.
            There is no general times operator supported for expressions in CPLEX.
            </summary>
      <param name="times">An Optimization.Model.Expression as Operator.Times</param>
      <returns>The expression for CPLEX</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex124.NumExprVisitor.VisitPlus(Optimization.Operators.Interfaces.IPlus)">
      <summary>
            Returns a new expression for CPLEX created as sum of all operands(INumExpr)
            </summary>
      <param name="plus">An Optimization.Model.Expression as Operator.Plus</param>
      <returns>The expression for CPLEX</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex124.NumExprVisitor.TimesScalar(System.Double,Optimization.Expression)">
      <summary>
            Builds up an expression consisting of an expression * factor
            </summary>
      <param name="factor">A constant</param>
      <param name="expr">An Optimization.Model.Expression</param>
      <returns>The expression for CPLEX</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex124.NumExprVisitor.TimesQuadratic(System.Double,ILOG.Concert.INumVar[])">
      <summary>
            Builds up an expression, which is possibly quadratic: factor * var1 (* var2)
            </summary>
      <param name="factor">A constant</param>
      <param name="vars">The variables of the quadratic expression</param>
      <returns>The quadratic expression for CPLEX</returns>
    </member>
    <member name="T:Optimization.Solver.Gurobi.SolverStatus">
      <summary>
            The Status of the Gurobi solver
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Cutoff">
      <summary>
            Cutoff
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Infeasible">
      <summary>
            Infeasible
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.InfOrUnbd">
      <summary>
            Infinity or Unbounded
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Interrupted">
      <summary>
            Interrupted
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.IterationLimit">
      <summary>
            IterationLimit
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Loaded">
      <summary>
            Loaded
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.NodeLimit">
      <summary>
            NodeLimit
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Numeric">
      <summary>
            Numeric
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Optimal">
      <summary>
            Optimal
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.SolutionLimit">
      <summary>
            SolutionLimit
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.TimeLimit">
      <summary>
            TimeLimit
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Unbounded">
      <summary>
            Unbounded
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Suboptimal">
      <summary>
            Suboptimal
            </summary>
    </member>
  </members>
</doc>